<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fragment-Shader on Theta Nil's Site</title><link>https://thetanil.github.io/tags/fragment-shader/</link><description>Recent content in Fragment-Shader on Theta Nil's Site</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 08 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://thetanil.github.io/tags/fragment-shader/index.xml" rel="self" type="application/rss+xml"/><item><title>SVG with Normalized Coordinates</title><link>https://thetanil.github.io/posts/svg_002/</link><pubDate>Wed, 08 Oct 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/svg_002/</guid><description>&lt;p&gt;This post demonstrates how to generate SVG content with JavaScript using normalized coordinates (-1 to 1) similar to fragment shaders.&lt;/p&gt;
&lt;div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;"&gt;
&lt;button onclick="startFragmentAnimation()" style="padding: 10px 15px; background: #8BC34A; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 150px;"&gt;üé¨ Animate Fragment Shader&lt;/button&gt;
&lt;button onclick="startCircleAnimation()" style="padding: 10px 15px; background: #03A9F4; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 150px;"&gt;üé¨ Animate Circles&lt;/button&gt;
&lt;button onclick="stopAnimation()" style="padding: 10px 15px; background: #F44336; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;‚èπÔ∏è Stop Animation&lt;/button&gt;
&lt;/div&gt;
&lt;div id="svg-container" style="width: 100%; height: 100vh; margin: 0; padding: 0;"&gt;&lt;/div&gt;
&lt;script&gt;
// Fragment shader-like functions
function length(x, y) {
 return Math.sqrt(x * x + y * y);
}

function mix(a, b, t) {
 return a * (1 - t) + b * t;
}

function smoothstep(edge0, edge1, x) {
 const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
 return t * t * (3 - 2 * t);
}

function fract(x) {
 return x - Math.floor(x);
}

function sin(x) {
 return Math.sin(x);
}

function cos(x) {
 return Math.cos(x);
}

// Convert normalized coordinates (-1 to 1) to SVG coordinates
function normToSvg(nx, ny, width, height) {
 const x = (nx + 1) * width * 0.5;
 const y = (-ny + 1) * height * 0.5; // Flip Y for SVG coordinate system
 return { x, y };
}

// Convert color components (0-1) to RGB string
function colorToRgb(r, g, b, a = 1) {
 return `rgba(${Math.floor(r * 255)}, ${Math.floor(g * 255)}, ${Math.floor(b * 255)}, ${a})`;
}

// Create a fragment shader-like pattern
function fragmentShader(nx, ny, time) {
 // Distance from center
 const dist = length(nx, ny);
 
 // Angle
 const angle = Math.atan2(ny, nx);
 
 // Create some patterns
 const rings = sin(dist * 10 - time * 2) * 0.5 + 0.5;
 const spiral = sin(angle * 8 + dist * 20 - time * 3) * 0.5 + 0.5;
 const waves = sin(nx * 10 + time) * sin(ny * 10 + time) * 0.5 + 0.5;
 
 // Combine patterns
 const r = rings * 0.8 + 0.2;
 const g = spiral * 0.6 + 0.4;
 const b = waves * 0.9 + 0.1;
 
 return { r, g, b };
}

function createSVGPattern() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 // Create SVG element
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', '100%');
 svg.setAttribute('height', 'auto');
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 
 // Resolution for the pattern (adjust for performance vs quality)
 const resolution = 100;
 const pixelWidth = width / resolution;
 const pixelHeight = height / resolution;
 
 // Get current time for animation
 const time = Date.now() * 0.001;
 
 // Generate pattern
 for (let i = 0; i &lt; resolution; i++) {
 for (let j = 0; j &lt; resolution; j++) {
 // Convert to normalized coordinates (-1 to 1)
 const nx = (i / resolution) * 2 - 1;
 const ny = (j / resolution) * 2 - 1;
 
 // Get color from fragment shader
 const color = fragmentShader(nx, ny, time);
 
 // Create rectangle for this "pixel"
 const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
 rect.setAttribute('x', i * pixelWidth);
 rect.setAttribute('y', j * pixelHeight);
 rect.setAttribute('width', pixelWidth);
 rect.setAttribute('height', pixelHeight);
 rect.setAttribute('fill', colorToRgb(color.r, color.g, color.b));
 
 svg.appendChild(rect);
 }
 }
 
 // Clear container and add SVG
 container.innerHTML = '';
 container.appendChild(svg);
}

// Higher resolution example with circles
function createHighResPattern() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', '100%');
 svg.setAttribute('height', 'auto');
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 
 const time = Date.now() * 0.001;
 const numCircles = 50;
 
 // Create animated circles using normalized coordinates
 for (let i = 0; i &lt; numCircles; i++) {
 const t = i / numCircles;
 
 // Use normalized coordinates for positioning
 const nx = sin(time + t * Math.PI * 2) * 0.8;
 const ny = cos(time * 1.3 + t * Math.PI * 2) * 0.8;
 
 // Convert to SVG coordinates
 const pos = normToSvg(nx, ny, width, height);
 
 // Create circle
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', pos.x);
 circle.setAttribute('cy', pos.y);
 circle.setAttribute('r', 10 + sin(time * 2 + t * 10) * 5);
 
 // Color based on normalized position
 const dist = length(nx, ny);
 const hue = (t * 360 + time * 50) % 360;
 circle.setAttribute('fill', `hsl(${hue}, 70%, ${60 + dist * 40}%)`);
 circle.setAttribute('opacity', 0.7);
 
 svg.appendChild(circle);
 }
 
 container.innerHTML = '';
 container.appendChild(svg);
}

// Mandelbrot-like pattern using normalized coordinates
function createMandelbrotPattern() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', '100%');
 svg.setAttribute('height', 'auto');
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 
 const resolution = 200;
 const pixelWidth = width / resolution;
 const pixelHeight = height / resolution;
 
 // Mandelbrot-like iteration
 function mandelbrot(cx, cy, maxIter = 20) {
 let x = 0, y = 0;
 let iter = 0;
 
 while (x * x + y * y &lt;= 4 &amp;&amp; iter &lt; maxIter) {
 const temp = x * x - y * y + cx;
 y = 2 * x * y + cy;
 x = temp;
 iter++;
 }
 
 return iter / maxIter;
 }
 
 for (let i = 0; i &lt; resolution; i++) {
 for (let j = 0; j &lt; resolution; j++) {
 // Normalized coordinates
 const nx = (i / resolution) * 3 - 1.5; // Zoom into interesting area
 const ny = (j / resolution) * 3 - 1.5;
 
 const value = mandelbrot(nx, ny);
 
 const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
 rect.setAttribute('x', i * pixelWidth);
 rect.setAttribute('y', j * pixelHeight);
 rect.setAttribute('width', pixelWidth);
 rect.setAttribute('height', pixelHeight);
 
 // Color mapping
 const hue = value * 360 + 200;
 const sat = value &gt; 0.95 ? 0 : 70;
 const light = value * 60 + 20;
 rect.setAttribute('fill', `hsl(${hue}, ${sat}%, ${light}%)`);
 
 svg.appendChild(rect);
 }
 }
 
 container.innerHTML = '';
 container.appendChild(svg);
}

// Animation state
let animationId = null;
let currentPattern = 'static';

// Initialize with pattern
createSVGPattern();

// Animation loops for different patterns
function animateFragmentShader() {
 if (currentPattern === 'fragment') {
 createSVGPattern();
 animationId = requestAnimationFrame(animateFragmentShader);
 }
}

function animateCircles() {
 if (currentPattern === 'circles') {
 createHighResPattern();
 animationId = requestAnimationFrame(animateCircles);
 }
}

function stopAnimation() {
 if (animationId) {
 cancelAnimationFrame(animationId);
 animationId = null;
 }
 currentPattern = 'static';
}

function startFragmentAnimation() {
 stopAnimation();
 currentPattern = 'fragment';
 animateFragmentShader();
}

function startCircleAnimation() {
 stopAnimation();
 currentPattern = 'circles';
 animateCircles();
}

// Handle window resize
window.addEventListener('resize', () =&gt; {
 if (currentPattern === 'static') {
 createSVGPattern();
 }
 // Animation will continue with the current pattern
});
&lt;/script&gt;
&lt;h2 id="key-concepts"&gt;Key Concepts&lt;/h2&gt;
&lt;h3 id="normalized-coordinates"&gt;Normalized Coordinates&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Convert screen position to normalized coordinates (-1 to 1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;i&lt;/span&gt; &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;resolution&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;j&lt;/span&gt; &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;resolution&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Convert normalized coordinates back to SVG coordinates
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;normToSvg&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;width&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;height&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;width&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;height&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// Flip Y for SVG
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; { &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="fragment-shader-like-functions"&gt;Fragment Shader-like Functions&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fragmentShader&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;time&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dist&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;length&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;angle&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; Math.&lt;span style="color:#a6e22e"&gt;atan2&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;rings&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;sin&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;dist&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;time&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;spiral&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;sin&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;angle&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;8&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dist&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;20&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;time&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;3&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; { &lt;span style="color:#a6e22e"&gt;r&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;rings&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;g&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;spiral&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;b&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.8&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="performance-considerations"&gt;Performance Considerations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Resolution&lt;/strong&gt;: Lower resolution = better performance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Animation&lt;/strong&gt;: Use &lt;code&gt;requestAnimationFrame&lt;/code&gt; for smooth animation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Batch Operations&lt;/strong&gt;: Create all elements before adding to DOM&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consider Canvas&lt;/strong&gt;: For very high-resolution patterns, HTML5 Canvas might be more efficient&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="advanced-techniques"&gt;Advanced Techniques&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Use viewBox&lt;/strong&gt;: Define custom coordinate systems&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Float Precision&lt;/strong&gt;: JavaScript numbers are 64-bit floats, perfect for shader-like calculations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color Spaces&lt;/strong&gt;: Convert between HSL, RGB, and normalized color values&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time-based Animation&lt;/strong&gt;: Use timestamps for consistent animation speed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interactive&lt;/strong&gt;: Add mouse/touch events for interactive experiences&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This approach gives you the flexibility of fragment shaders with the scalability and styling capabilities of SVG!&lt;/p&gt;</description></item></channel></rss>