<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Intersection on Theta Nil's Site</title><link>https://thetanil.github.io/tags/intersection/</link><description>Recent content in Intersection on Theta Nil's Site</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 08 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://thetanil.github.io/tags/intersection/index.xml" rel="self" type="application/rss+xml"/><item><title>Line Intersection Detection and Splitting</title><link>https://thetanil.github.io/posts/svg_004/</link><pubDate>Wed, 08 Oct 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/svg_004/</guid><description>&lt;p&gt;This post demonstrates efficient line intersection detection using SVG-optimized techniques, with automatic circle placement and visual line splitting effects.&lt;/p&gt;
&lt;h3 id="intersection-demos"&gt;Intersection Demos:&lt;/h3&gt;
&lt;div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;"&gt;
&lt;button onclick="stopAnimation(); createStaticIntersectionDemo();" style="padding: 10px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;Static Intersections&lt;/button&gt;
&lt;button onclick="stopAnimation(); createInteractiveDemo();" style="padding: 10px 15px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;Interactive Lines&lt;/button&gt;
&lt;button onclick="startAnimation();" style="padding: 10px 15px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;üé¨ Animated Intersections&lt;/button&gt;
&lt;button onclick="stopAnimation()" style="padding: 10px 15px; background: #F44336; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;‚èπÔ∏è Stop Animation&lt;/button&gt;
&lt;/div&gt;
&lt;div id="svg-container" style="width: 100%; height: 100vh; margin: 0; padding: 0; background: #111;"&gt;&lt;/div&gt;
&lt;script&gt;
// SVG-optimized intersection utilities
function bboxIntersect(bbox1, bbox2) {
 return !(bbox1.x + bbox1.width &lt; bbox2.x || 
 bbox2.x + bbox2.width &lt; bbox1.x || 
 bbox1.y + bbox1.height &lt; bbox2.y || 
 bbox2.y + bbox2.height &lt; bbox1.y);
}

function getLineFromElement(line) {
 return {
 x1: parseFloat(line.getAttribute('x1')),
 y1: parseFloat(line.getAttribute('y1')),
 x2: parseFloat(line.getAttribute('x2')),
 y2: parseFloat(line.getAttribute('y2'))
 };
}

function lineIntersection(line1, line2) {
 const x1 = line1.x1, y1 = line1.y1, x2 = line1.x2, y2 = line1.y2;
 const x3 = line2.x1, y3 = line2.y1, x4 = line2.x2, y4 = line2.y2;
 
 const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
 if (Math.abs(denom) &lt; 1e-10) return null; // Parallel lines
 
 const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
 const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
 
 // Check if intersection is within both line segments
 if (t &gt;= 0 &amp;&amp; t &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1) {
 return {
 x: x1 + t * (x2 - x1),
 y: y1 + t * (y2 - y1),
 t1: t,
 t2: u
 };
 }
 
 return null;
}

// Animation and interaction state
let animationId = null;
let isAnimating = false;
let lines = [];
let intersections = [];
let isDragging = false;
let dragTarget = null;
let dragOffset = { x: 0, y: 0 };

function createStaticIntersectionDemo() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#111';
 
 // Create grid background
 const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
 const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
 pattern.setAttribute('id', 'grid');
 pattern.setAttribute('width', '50');
 pattern.setAttribute('height', '50');
 pattern.setAttribute('patternUnits', 'userSpaceOnUse');
 
 const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
 gridPath.setAttribute('d', 'M 50 0 L 0 0 0 50');
 gridPath.setAttribute('fill', 'none');
 gridPath.setAttribute('stroke', '#333');
 gridPath.setAttribute('stroke-width', '1');
 gridPath.setAttribute('opacity', '0.3');
 
 pattern.appendChild(gridPath);
 defs.appendChild(pattern);
 svg.appendChild(defs);
 
 const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
 gridRect.setAttribute('width', '100%');
 gridRect.setAttribute('height', '100%');
 gridRect.setAttribute('fill', 'url(#grid)');
 svg.appendChild(gridRect);
 
 // Define static lines for demonstration
 const staticLines = [
 { x1: 100, y1: 100, x2: width - 100, y2: height - 100, color: '#ff6b6b' },
 { x1: width - 100, y1: 100, x2: 100, y2: height - 100, color: '#4ecdc4' },
 { x1: width * 0.2, y1: height * 0.8, x2: width * 0.8, y2: height * 0.2, color: '#45b7d1' },
 { x1: width * 0.5, y1: 50, x2: width * 0.5, y2: height - 50, color: '#96ceb4' },
 { x1: 50, y1: height * 0.5, x2: width - 50, y2: height * 0.5, color: '#ffeaa7' }
 ];
 
 // Draw lines
 staticLines.forEach((lineData, index) =&gt; {
 const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 line.setAttribute('x1', lineData.x1);
 line.setAttribute('y1', lineData.y1);
 line.setAttribute('x2', lineData.x2);
 line.setAttribute('y2', lineData.y2);
 line.setAttribute('stroke', lineData.color);
 line.setAttribute('stroke-width', '3');
 line.setAttribute('opacity', '0.8');
 line.setAttribute('id', `line-${index}`);
 svg.appendChild(line);
 });
 
 // Find all intersections
 const lineElements = svg.querySelectorAll('line');
 const foundIntersections = [];
 
 for (let i = 0; i &lt; lineElements.length; i++) {
 for (let j = i + 1; j &lt; lineElements.length; j++) {
 const line1 = getLineFromElement(lineElements[i]);
 const line2 = getLineFromElement(lineElements[j]);
 
 // Quick bounding box check first (SVG optimization)
 const bbox1 = lineElements[i].getBBox();
 const bbox2 = lineElements[j].getBBox();
 
 if (bboxIntersect(bbox1, bbox2)) {
 const intersection = lineIntersection(line1, line2);
 if (intersection) {
 foundIntersections.push({
 ...intersection,
 line1Index: i,
 line2Index: j
 });
 }
 }
 }
 }
 
 // Draw intersection circles
 foundIntersections.forEach((intersection, index) =&gt; {
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', intersection.x);
 circle.setAttribute('cy', intersection.y);
 circle.setAttribute('r', '8');
 circle.setAttribute('fill', '#ff9ff3');
 circle.setAttribute('stroke', '#fff');
 circle.setAttribute('stroke-width', '2');
 circle.setAttribute('opacity', '0.9');
 
 // Add pulsing animation
 const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
 animate.setAttribute('attributeName', 'r');
 animate.setAttribute('values', '8;12;8');
 animate.setAttribute('dur', '2s');
 animate.setAttribute('repeatCount', 'indefinite');
 circle.appendChild(animate);
 
 svg.appendChild(circle);
 
 // Add intersection label
 const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 text.setAttribute('x', intersection.x + 15);
 text.setAttribute('y', intersection.y - 10);
 text.setAttribute('fill', '#fff');
 text.setAttribute('font-size', '12');
 text.setAttribute('font-family', 'monospace');
 text.textContent = `(${Math.round(intersection.x)}, ${Math.round(intersection.y)})`;
 svg.appendChild(text);
 });
 
 // Add intersection count
 const countText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 countText.setAttribute('x', '20');
 countText.setAttribute('y', '30');
 countText.setAttribute('fill', '#fff');
 countText.setAttribute('font-size', '16');
 countText.setAttribute('font-family', 'monospace');
 countText.textContent = `Intersections found: ${foundIntersections.length}`;
 svg.appendChild(countText);
 
 container.appendChild(svg);
}

function createInteractiveDemo() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#111';
 svg.style.cursor = 'crosshair';
 
 // Initialize draggable lines
 lines = [
 { x1: 200, y1: 200, x2: width - 200, y2: height - 200, color: '#ff6b6b' },
 { x1: width - 200, y1: 200, x2: 200, y2: height - 200, color: '#4ecdc4' },
 { x1: width * 0.3, y1: height * 0.8, x2: width * 0.7, y2: height * 0.2, color: '#45b7d1' }
 ];
 
 function updateDisplay() {
 // Clear previous content
 while (svg.firstChild) {
 svg.removeChild(svg.firstChild);
 }
 
 // Find intersections
 intersections = [];
 for (let i = 0; i &lt; lines.length; i++) {
 for (let j = i + 1; j &lt; lines.length; j++) {
 const intersection = lineIntersection(lines[i], lines[j]);
 if (intersection) {
 intersections.push({
 ...intersection,
 line1: i,
 line2: j
 });
 }
 }
 }
 
 // Draw lines with splitting effect
 lines.forEach((line, index) =&gt; {
 const segments = getLineSplitSegments(line, index);
 
 segments.forEach((segment, segIndex) =&gt; {
 const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 lineEl.setAttribute('x1', segment.x1);
 lineEl.setAttribute('y1', segment.y1);
 lineEl.setAttribute('x2', segment.x2);
 lineEl.setAttribute('y2', segment.y2);
 lineEl.setAttribute('stroke', line.color);
 lineEl.setAttribute('stroke-width', '4');
 lineEl.setAttribute('opacity', segment.isGap ? '0.3' : '0.9');
 lineEl.setAttribute('stroke-dasharray', segment.isGap ? '5,5' : 'none');
 svg.appendChild(lineEl);
 });
 
 // Draw draggable endpoints
 [{ x: line.x1, y: line.y1, type: 'start' }, { x: line.x2, y: line.y2, type: 'end' }].forEach(point =&gt; {
 const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 handle.setAttribute('cx', point.x);
 handle.setAttribute('cy', point.y);
 handle.setAttribute('r', '8');
 handle.setAttribute('fill', line.color);
 handle.setAttribute('stroke', '#fff');
 handle.setAttribute('stroke-width', '2');
 handle.setAttribute('opacity', '0.8');
 handle.style.cursor = 'grab';
 handle.dataset.lineIndex = index;
 handle.dataset.pointType = point.type;
 svg.appendChild(handle);
 });
 });
 
 // Draw intersection circles
 intersections.forEach((intersection, index) =&gt; {
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', intersection.x);
 circle.setAttribute('cy', intersection.y);
 circle.setAttribute('r', '6');
 circle.setAttribute('fill', '#ff9ff3a0');
 circle.setAttribute('stroke', '#ff9ff3');
 circle.setAttribute('stroke-width', '2');
 svg.appendChild(circle);
 });
 
 // Add instruction text
 const instructionText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 instructionText.setAttribute('x', '20');
 instructionText.setAttribute('y', '30');
 instructionText.setAttribute('fill', '#fff');
 instructionText.setAttribute('font-size', '14');
 instructionText.setAttribute('font-family', 'Arial');
 instructionText.textContent = `Drag line endpoints to see intersections update | Intersections: ${intersections.length}`;
 svg.appendChild(instructionText);
 }
 
 function getLineSplitSegments(line, lineIndex) {
 // Find intersections that affect this line
 const relevantIntersections = intersections
 .filter(int =&gt; int.line1 === lineIndex || int.line2 === lineIndex)
 .map(int =&gt; ({
 x: int.x,
 y: int.y,
 t: int.line1 === lineIndex ? int.t1 : int.t2
 }))
 .sort((a, b) =&gt; a.t - b.t);
 
 if (relevantIntersections.length === 0) {
 return [line];
 }
 
 const segments = [];
 let lastT = 0;
 
 relevantIntersections.forEach((intersection, index) =&gt; {
 // Add segment before intersection
 if (intersection.t &gt; lastT) {
 segments.push({
 x1: line.x1 + lastT * (line.x2 - line.x1),
 y1: line.y1 + lastT * (line.y2 - line.y1),
 x2: line.x1 + intersection.t * (line.x2 - line.x1),
 y2: line.y1 + intersection.t * (line.y2 - line.y1),
 isGap: false
 });
 }
 
 // Add gap around intersection
 const gapSize = 0.02;
 const gapStart = Math.max(0, intersection.t - gapSize);
 const gapEnd = Math.min(1, intersection.t + gapSize);
 
 if (gapEnd &lt; 1) {
 segments.push({
 x1: line.x1 + gapStart * (line.x2 - line.x1),
 y1: line.y1 + gapStart * (line.y2 - line.y1),
 x2: line.x1 + gapEnd * (line.x2 - line.x1),
 y2: line.y1 + gapEnd * (line.y2 - line.y1),
 isGap: true
 });
 }
 
 lastT = gapEnd;
 });
 
 // Add final segment
 if (lastT &lt; 1) {
 segments.push({
 x1: line.x1 + lastT * (line.x2 - line.x1),
 y1: line.y1 + lastT * (line.y2 - line.y1),
 x2: line.x2,
 y2: line.y2,
 isGap: false
 });
 }
 
 return segments;
 }
 
 // Mouse event handlers
 svg.addEventListener('mousedown', (e) =&gt; {
 const rect = svg.getBoundingClientRect();
 const x = e.clientX - rect.left;
 const y = e.clientY - rect.top;
 
 // Check if clicking on a handle
 const handle = e.target;
 if (handle.dataset.lineIndex !== undefined) {
 isDragging = true;
 dragTarget = {
 lineIndex: parseInt(handle.dataset.lineIndex),
 pointType: handle.dataset.pointType
 };
 handle.style.cursor = 'grabbing';
 }
 });
 
 svg.addEventListener('mousemove', (e) =&gt; {
 if (!isDragging || !dragTarget) return;
 
 const rect = svg.getBoundingClientRect();
 const x = e.clientX - rect.left;
 const y = e.clientY - rect.top;
 
 const line = lines[dragTarget.lineIndex];
 if (dragTarget.pointType === 'start') {
 line.x1 = x;
 line.y1 = y;
 } else {
 line.x2 = x;
 line.y2 = y;
 }
 
 updateDisplay();
 });
 
 svg.addEventListener('mouseup', () =&gt; {
 isDragging = false;
 dragTarget = null;
 svg.querySelectorAll('circle').forEach(handle =&gt; {
 handle.style.cursor = 'grab';
 });
 });
 
 updateDisplay();
 container.appendChild(svg);
}

function createAnimatedIntersections() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#111';
 
 function animate() {
 if (!isAnimating) return;
 
 const time = Date.now() * 0.001;
 
 // Clear previous content
 while (svg.firstChild) {
 svg.removeChild(svg.firstChild);
 }
 
 // Create moving lines
 const movingLines = [
 {
 x1: width * 0.1,
 y1: height * 0.5 + Math.sin(time) * height * 0.3,
 x2: width * 0.9,
 y2: height * 0.5 + Math.cos(time * 1.3) * height * 0.3,
 color: '#ff6b6b'
 },
 {
 x1: width * 0.5 + Math.cos(time * 0.7) * width * 0.3,
 y1: height * 0.1,
 x2: width * 0.5 + Math.sin(time * 0.9) * width * 0.3,
 y2: height * 0.9,
 color: '#4ecdc4'
 },
 {
 x1: width * 0.2 + Math.sin(time * 1.1) * width * 0.2,
 y1: height * 0.8,
 x2: width * 0.8 + Math.cos(time * 0.8) * width * 0.2,
 y2: height * 0.2,
 color: '#45b7d1'
 }
 ];
 
 // Draw lines
 movingLines.forEach(line =&gt; {
 const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 lineEl.setAttribute('x1', line.x1);
 lineEl.setAttribute('y1', line.y1);
 lineEl.setAttribute('x2', line.x2);
 lineEl.setAttribute('y2', line.y2);
 lineEl.setAttribute('stroke', line.color);
 lineEl.setAttribute('stroke-width', '3');
 lineEl.setAttribute('opacity', '0.8');
 svg.appendChild(lineEl);
 });
 
 // Find and draw intersections
 const currentIntersections = [];
 for (let i = 0; i &lt; movingLines.length; i++) {
 for (let j = i + 1; j &lt; movingLines.length; j++) {
 const intersection = lineIntersection(movingLines[i], movingLines[j]);
 if (intersection) {
 currentIntersections.push(intersection);
 }
 }
 }
 
 currentIntersections.forEach(intersection =&gt; {
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', intersection.x);
 circle.setAttribute('cy', intersection.y);
 circle.setAttribute('r', '10');
 circle.setAttribute('fill', '#ff9ff3');
 circle.setAttribute('stroke', '#fff');
 circle.setAttribute('stroke-width', '2');
 circle.setAttribute('opacity', '0.9');
 svg.appendChild(circle);
 
 // Add ripple effect
 const ripple = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 ripple.setAttribute('cx', intersection.x);
 ripple.setAttribute('cy', intersection.y);
 ripple.setAttribute('r', '15');
 ripple.setAttribute('fill', 'none');
 ripple.setAttribute('stroke', '#ff9ff3');
 ripple.setAttribute('stroke-width', '1');
 ripple.setAttribute('opacity', '0.5');
 svg.appendChild(ripple);
 });
 
 // Add intersection count
 const countText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 countText.setAttribute('x', '20');
 countText.setAttribute('y', '30');
 countText.setAttribute('fill', '#fff');
 countText.setAttribute('font-size', '16');
 countText.setAttribute('font-family', 'monospace');
 countText.textContent = `Live Intersections: ${currentIntersections.length}`;
 svg.appendChild(countText);
 
 animationId = requestAnimationFrame(animate);
 }
 
 container.appendChild(svg);
 animate();
}

function startAnimation() {
 isAnimating = true;
 createAnimatedIntersections();
}

function stopAnimation() {
 isAnimating = false;
 if (animationId) {
 cancelAnimationFrame(animationId);
 animationId = null;
 }
}

// Initialize
createStaticIntersectionDemo();

// Handle window resize
window.addEventListener('resize', () =&gt; {
 if (!isAnimating) {
 createStaticIntersectionDemo();
 }
});
&lt;/script&gt;
&lt;h2 id="svg-optimization-techniques"&gt;SVG Optimization Techniques&lt;/h2&gt;
&lt;h3 id="1-bounding-box-pre-filtering"&gt;1. &lt;strong&gt;Bounding Box Pre-filtering&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bboxIntersect&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#f92672"&gt;!&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;width&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;||&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;width&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;||&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;height&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;||&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;height&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Quick elimination before expensive intersection math
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;bboxIntersect&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;line1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getBBox&lt;/span&gt;(), &lt;span style="color:#a6e22e"&gt;line2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getBBox&lt;/span&gt;())) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Only then do precise intersection calculation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="2-svg-coordinate-extraction"&gt;2. &lt;strong&gt;SVG Coordinate Extraction&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;getLineFromElement&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;x1&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; parseFloat(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;x1&amp;#39;&lt;/span&gt;)),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;y1&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; parseFloat(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;y1&amp;#39;&lt;/span&gt;)),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;x2&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; parseFloat(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;x2&amp;#39;&lt;/span&gt;)),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;y2&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; parseFloat(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;y2&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="3-visual-line-splitting"&gt;3. &lt;strong&gt;Visual Line Splitting&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;getLineSplitSegments&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;intersections&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Creates visual gaps at intersection points
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// More efficient than creating separate path elements
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;segments&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; [];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;intersections&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;forEach&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;intersection&lt;/span&gt; =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Add gap around intersection point
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;gapSize&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.02&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 2% of line length
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Split line into segments with gaps
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;segments&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="4-efficient-intersection-algorithm"&gt;4. &lt;strong&gt;Efficient Intersection Algorithm&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineIntersection&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;line1&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;line2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Parametric line intersection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Returns null for parallel lines (early exit)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Checks if intersection is within line segments
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Returns intersection point with parameter values
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="performance-features"&gt;Performance Features&lt;/h2&gt;
&lt;h3 id="optimization-strategies"&gt;&lt;strong&gt;Optimization Strategies:&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Bounding Box Testing&lt;/strong&gt;: Quick elimination of non-intersecting line pairs&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SVG Native Coordinates&lt;/strong&gt;: Direct attribute access without transformations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parametric Intersection&lt;/strong&gt;: Mathematical precision with early exits&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visual Effects&lt;/strong&gt;: Line splitting and gap rendering&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Real-time Updates&lt;/strong&gt;: Efficient redraw strategies&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="interactive-features"&gt;&lt;strong&gt;Interactive Features:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Draggable Endpoints&lt;/strong&gt;: Move line endpoints to see live intersection updates&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visual Splitting&lt;/strong&gt;: Lines break at intersection points with dashed gaps&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Real-time Counting&lt;/strong&gt;: Dynamic intersection count display&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smooth Animation&lt;/strong&gt;: Moving lines with continuous intersection detection&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="svg-specific-benefits"&gt;&lt;strong&gt;SVG-Specific Benefits:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Direct Coordinate Access&lt;/strong&gt;: &lt;code&gt;getAttribute()&lt;/code&gt; for line positions&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Built-in Bounding Boxes&lt;/strong&gt;: &lt;code&gt;getBBox()&lt;/code&gt; for quick spatial queries&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Native Rendering&lt;/strong&gt;: Hardware-accelerated line and circle drawing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event Integration&lt;/strong&gt;: Mouse events directly on SVG elements&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This system demonstrates how SVG&amp;rsquo;s built-in features can optimize geometric calculations and provide smooth interactive experiences!&lt;/p&gt;</description></item></channel></rss>