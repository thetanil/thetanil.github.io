<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Intersection on Theta Nil's Site</title><link>https://thetanil.github.io/tags/intersection/</link><description>Recent content in Intersection on Theta Nil's Site</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 10 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://thetanil.github.io/tags/intersection/index.xml" rel="self" type="application/rss+xml"/><item><title>Triangle-Circle Intersection Detection with Curved Motion</title><link>https://thetanil.github.io/posts/svg_005/</link><pubDate>Fri, 10 Oct 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/svg_005/</guid><description>&lt;p&gt;This post demonstrates real-time intersection detection between a moving triangle and a moving circle, with automatic marking of intersection points as the shapes follow curved paths.&lt;/p&gt;
&lt;h3 id="intersection-demos"&gt;Intersection Demos:&lt;/h3&gt;
&lt;div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;"&gt;
&lt;button onclick="startAnimation();" style="padding: 10px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;üé¨ Start Animation&lt;/button&gt;
&lt;button onclick="stopAnimation()" style="padding: 10px 15px; background: #F44336; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;‚èπÔ∏è Stop Animation&lt;/button&gt;
&lt;button onclick="togglePaths()" style="padding: 10px 15px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;üëÅÔ∏è Toggle Paths&lt;/button&gt;
&lt;button onclick="clearIntersections()" style="padding: 10px 15px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;üßπ Clear Points&lt;/button&gt;
&lt;/div&gt;
&lt;div style="margin: 10px 0;"&gt;
&lt;label style="color: white; margin-right: 10px;"&gt;Speed:&lt;/label&gt;
&lt;input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1" style="margin-right: 10px;" onchange="updateSpeed(this.value)"&gt;
&lt;span id="speedValue" style="color: white;"&gt;1.0x&lt;/span&gt;
&lt;/div&gt;
&lt;div id="svg-container" style="width: 100%; height: 100vh; margin: 0; padding: 0; background: #111;"&gt;&lt;/div&gt;
&lt;script&gt;
// Animation state
let animationId = null;
let isAnimating = false;
let animationSpeed = 1.0;
let startTime = 0;
let showPaths = true;

// Shape parameters
const triangleSize = 80;
const circleRadius = 50;
let svg = null;
let triangle = null;
let circle = null;
let intersectionPoints = [];
let persistentIntersections = [];

function initializeSVG() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', '100%');
 svg.setAttribute('height', 'auto');
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#111';
 
 // Create gradient definitions
 const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
 
 // Triangle gradient
 const triangleGradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
 triangleGradient.setAttribute('id', 'triangleGradient');
 triangleGradient.setAttribute('cx', '50%');
 triangleGradient.setAttribute('cy', '50%');
 
 const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
 stop1.setAttribute('offset', '0%');
 stop1.setAttribute('stop-color', '#ff6b6b');
 stop1.setAttribute('stop-opacity', '0.8');
 
 const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
 stop2.setAttribute('offset', '100%');
 stop2.setAttribute('stop-color', '#ff3333');
 stop2.setAttribute('stop-opacity', '0.6');
 
 triangleGradient.appendChild(stop1);
 triangleGradient.appendChild(stop2);
 defs.appendChild(triangleGradient);
 
 // Circle gradient
 const circleGradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
 circleGradient.setAttribute('id', 'circleGradient');
 circleGradient.setAttribute('cx', '50%');
 circleGradient.setAttribute('cy', '50%');
 
 const circleStop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
 circleStop1.setAttribute('offset', '0%');
 circleStop1.setAttribute('stop-color', '#4ecdc4');
 circleStop1.setAttribute('stop-opacity', '0.8');
 
 const circleStop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
 circleStop2.setAttribute('offset', '100%');
 circleStop2.setAttribute('stop-color', '#45b7d1');
 circleStop2.setAttribute('stop-opacity', '0.6');
 
 circleGradient.appendChild(circleStop1);
 circleGradient.appendChild(circleStop2);
 defs.appendChild(circleGradient);
 
 svg.appendChild(defs);
 
 // Create background grid
 createGrid();
 
 // Create path guides (optional visibility)
 createPathGuides(width, height);
 
 // Create triangle
 triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
 triangle.setAttribute('fill', 'url(#triangleGradient)');
 triangle.setAttribute('stroke', '#fff');
 triangle.setAttribute('stroke-width', '2');
 triangle.setAttribute('opacity', '0.9');
 svg.appendChild(triangle);
 
 // Create circle
 circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('fill', 'url(#circleGradient)');
 circle.setAttribute('stroke', '#fff');
 circle.setAttribute('stroke-width', '2');
 circle.setAttribute('opacity', '0.9');
 circle.setAttribute('r', circleRadius);
 svg.appendChild(circle);
 
 container.appendChild(svg);
 
 return { width, height };
}

function createGrid() {
 const width = window.innerWidth;
 const height = window.innerHeight;
 const gridSize = 50;
 
 const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
 gridGroup.setAttribute('opacity', '0.1');
 gridGroup.setAttribute('id', 'grid');
 
 // Vertical lines
 for (let x = 0; x &lt;= width; x += gridSize) {
 const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 line.setAttribute('x1', x);
 line.setAttribute('y1', 0);
 line.setAttribute('x2', x);
 line.setAttribute('y2', height);
 line.setAttribute('stroke', '#fff');
 line.setAttribute('stroke-width', '1');
 gridGroup.appendChild(line);
 }
 
 // Horizontal lines
 for (let y = 0; y &lt;= height; y += gridSize) {
 const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 line.setAttribute('x1', 0);
 line.setAttribute('y1', y);
 line.setAttribute('x2', width);
 line.setAttribute('y2', y);
 line.setAttribute('stroke', '#fff');
 line.setAttribute('stroke-width', '1');
 gridGroup.appendChild(line);
 }
 
 svg.appendChild(gridGroup);
}

function createPathGuides(width, height) {
 const pathGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
 pathGroup.setAttribute('id', 'pathGuides');
 pathGroup.setAttribute('opacity', showPaths ? '0.3' : '0');
 
 // Triangle path (large circle)
 const trianglePath = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 trianglePath.setAttribute('cx', width / 2);
 trianglePath.setAttribute('cy', height / 2);
 trianglePath.setAttribute('r', 180);
 trianglePath.setAttribute('fill', 'none');
 trianglePath.setAttribute('stroke', '#ff6b6b');
 trianglePath.setAttribute('stroke-width', '2');
 trianglePath.setAttribute('stroke-dasharray', '5,5');
 pathGroup.appendChild(trianglePath);
 
 // Circle path (smaller circle, intersecting)
 const circlePath = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circlePath.setAttribute('cx', width / 2);
 circlePath.setAttribute('cy', height / 2);
 circlePath.setAttribute('r', 120);
 circlePath.setAttribute('fill', 'none');
 circlePath.setAttribute('stroke', '#4ecdc4');
 circlePath.setAttribute('stroke-width', '2');
 circlePath.setAttribute('stroke-dasharray', '5,5');
 pathGroup.appendChild(circlePath);
 
 svg.appendChild(pathGroup);
}

function getTrianglePoints(x, y, size, rotation = 0) {
 const height = size * Math.sqrt(3) / 2;
 const points = [
 { x: 0, y: -height * 2/3 },
 { x: -size/2, y: height * 1/3 },
 { x: size/2, y: height * 1/3 }
 ];
 
 // Apply rotation
 const cos = Math.cos(rotation);
 const sin = Math.sin(rotation);
 
 const rotatedPoints = points.map(point =&gt; {
 const rotatedX = point.x * cos - point.y * sin;
 const rotatedY = point.x * sin + point.y * cos;
 return { x: x + rotatedX, y: y + rotatedY };
 });
 
 return {
 points: rotatedPoints,
 pointsString: rotatedPoints.map(p =&gt; `${p.x},${p.y}`).join(' ')
 };
}

function calculateTrianglePosition(time) {
 const width = window.innerWidth;
 const height = window.innerHeight;
 const centerX = width / 2;
 const centerY = height / 2;
 const a = 180;
 
 // Large circular path for triangle (clockwise)
 const x = centerX + Math.cos(time) * a;
 const y = centerY + Math.sin(time) * a;
 const rotation = time + Math.PI / 2; // Point in direction of movement
 
 return { x, y, rotation };
}

function calculateCirclePosition(time) {
 const width = window.innerWidth;
 const height = window.innerHeight;
 const centerX = width / 2;
 const centerY = height / 2;
 const radius = 120;
 
 // Smaller circular path for circle (counter-clockwise, faster)
 const x = centerX + Math.cos(-time * 1.5) * radius;
 const y = centerY + Math.sin(-time * 1.5) * radius;
 
 return { x, y };
}

// Triangle-Circle intersection detection
function pointInTriangle(point, triangle) {
 const [a, b, c] = triangle.points;
 
 // Barycentric coordinate system
 const v0x = c.x - a.x;
 const v0y = c.y - a.y;
 const v1x = b.x - a.x;
 const v1y = b.y - a.y;
 const v2x = point.x - a.x;
 const v2y = point.y - a.y;
 
 const dot00 = v0x * v0x + v0y * v0y;
 const dot01 = v0x * v1x + v0y * v1y;
 const dot02 = v0x * v2x + v0y * v2y;
 const dot11 = v1x * v1x + v1y * v1y;
 const dot12 = v1x * v2x + v1y * v2y;
 
 const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
 const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
 const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
 
 return (u &gt;= 0) &amp;&amp; (v &gt;= 0) &amp;&amp; (u + v &lt;= 1);
}

function lineCircleIntersection(lineStart, lineEnd, circleCenter, radius) {
 const dx = lineEnd.x - lineStart.x;
 const dy = lineEnd.y - lineStart.y;
 const fx = lineStart.x - circleCenter.x;
 const fy = lineStart.y - circleCenter.y;
 
 const a = dx * dx + dy * dy;
 const b = 2 * (fx * dx + fy * dy);
 const c = (fx * fx + fy * fy) - radius * radius;
 
 const discriminant = b * b - 4 * a * c;
 
 if (discriminant &lt; 0) {
 return [];
 }
 
 const discriminantSqrt = Math.sqrt(discriminant);
 const t1 = (-b - discriminantSqrt) / (2 * a);
 const t2 = (-b + discriminantSqrt) / (2 * a);
 
 const intersections = [];
 
 if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
 intersections.push({
 x: lineStart.x + t1 * dx,
 y: lineStart.y + t1 * dy
 });
 }
 
 if (t2 &gt;= 0 &amp;&amp; t2 &lt;= 1 &amp;&amp; t2 !== t1) {
 intersections.push({
 x: lineStart.x + t2 * dx,
 y: lineStart.y + t2 * dy
 });
 }
 
 return intersections;
}

function findTriangleCircleIntersections(triangleData, circleCenter, radius) {
 const intersections = [];
 const triangle = triangleData.points;
 
 // Check each edge of triangle against circle
 for (let i = 0; i &lt; triangle.length; i++) {
 const start = triangle[i];
 const end = triangle[(i + 1) % triangle.length];
 
 const edgeIntersections = lineCircleIntersection(start, end, circleCenter, radius);
 intersections.push(...edgeIntersections);
 }
 
 // Check if circle center is inside triangle
 if (pointInTriangle(circleCenter, triangleData)) {
 intersections.push({
 x: circleCenter.x,
 y: circleCenter.y,
 type: 'center-inside-triangle'
 });
 }
 
 return intersections;
}

function animate() {
 if (!isAnimating) return;
 
 const currentTime = Date.now();
 if (startTime === 0) startTime = currentTime;
 
 const elapsedTime = (currentTime - startTime) * 0.001 * animationSpeed;
 
 // Calculate positions
 const trianglePos = calculateTrianglePosition(elapsedTime);
 const circlePos = calculateCirclePosition(elapsedTime);
 
 // Update triangle
 const triangleData = getTrianglePoints(trianglePos.x, trianglePos.y, triangleSize, trianglePos.rotation);
 triangle.setAttribute('points', triangleData.pointsString);
 
 // Update circle
 circle.setAttribute('cx', circlePos.x);
 circle.setAttribute('cy', circlePos.y);
 
 // Find intersections
 const currentIntersections = findTriangleCircleIntersections(
 triangleData, 
 circlePos, 
 circleRadius
 );
 
 // Add current intersections to persistent list (avoid duplicates)
 currentIntersections.forEach(intersection =&gt; {
 const isDuplicate = persistentIntersections.some(existing =&gt; 
 Math.abs(existing.x - intersection.x) &lt; 5 &amp;&amp; 
 Math.abs(existing.y - intersection.y) &lt; 5
 );
 
 if (!isDuplicate) {
 persistentIntersections.push({
 ...intersection,
 timestamp: elapsedTime,
 id: Date.now() + Math.random()
 });
 }
 });
 
 // Remove old intersections (older than 10 seconds)
 persistentIntersections = persistentIntersections.filter(
 intersection =&gt; elapsedTime - intersection.timestamp &lt; 10
 );
 
 // Update intersection display
 updateIntersectionDisplay(currentIntersections);
 updatePersistentIntersectionDisplay();
 
 // Update info text
 updateInfoText(trianglePos, circlePos, currentIntersections.length, persistentIntersections.length, elapsedTime);
 
 animationId = requestAnimationFrame(animate);
}

function updateIntersectionDisplay(intersections) {
 // Remove existing current intersection markers
 const existingCurrent = svg.querySelectorAll('.current-intersection');
 existingCurrent.forEach(marker =&gt; svg.removeChild(marker));
 
 // Draw current intersections
 intersections.forEach((intersection, index) =&gt; {
 const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 marker.setAttribute('cx', intersection.x);
 marker.setAttribute('cy', intersection.y);
 marker.setAttribute('r', '8');
 marker.setAttribute('fill', '#ff9ff3');
 marker.setAttribute('stroke', '#fff');
 marker.setAttribute('stroke-width', '3');
 marker.setAttribute('opacity', '0.9');
 marker.setAttribute('class', 'current-intersection');
 
 // Add pulsing animation
 const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
 animate.setAttribute('attributeName', 'r');
 animate.setAttribute('values', '8;12;8');
 animate.setAttribute('dur', '1s');
 animate.setAttribute('repeatCount', 'indefinite');
 marker.appendChild(animate);
 
 svg.appendChild(marker);
 });
}

function updatePersistentIntersectionDisplay() {
 // Remove existing persistent markers
 const existingPersistent = svg.querySelectorAll('.persistent-intersection');
 existingPersistent.forEach(marker =&gt; svg.removeChild(marker));
 
 // Draw persistent intersections with fading opacity
 persistentIntersections.forEach(intersection =&gt; {
 const age = Date.now() * 0.001 - intersection.timestamp;
 const opacity = Math.max(0.1, 1 - age / 10); // Fade over 10 seconds
 
 const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 marker.setAttribute('cx', intersection.x);
 marker.setAttribute('cy', intersection.y);
 marker.setAttribute('r', '4');
 marker.setAttribute('fill', '#ffff00');
 marker.setAttribute('stroke', '#fff');
 marker.setAttribute('stroke-width', '1');
 marker.setAttribute('opacity', opacity);
 marker.setAttribute('class', 'persistent-intersection');
 
 svg.appendChild(marker);
 });
}

function updateInfoText(trianglePos, circlePos, currentCount, totalCount, time) {
 // Remove existing info text
 const existingInfo = svg.querySelector('#infoText');
 if (existingInfo) {
 svg.removeChild(existingInfo);
 }
 
 const infoGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
 infoGroup.setAttribute('id', 'infoText');
 
 const texts = [
 `Triangle: (${Math.round(trianglePos.x)}, ${Math.round(trianglePos.y)}) | Rotation: ${(trianglePos.rotation * 180 / Math.PI).toFixed(1)}¬∞`,
 `Circle: (${Math.round(circlePos.x)}, ${Math.round(circlePos.y)}) | Radius: ${circleRadius}px`,
 `Current Intersections: ${currentCount} | Total Detected: ${totalCount}`,
 `Speed: ${animationSpeed.toFixed(1)}x | Time: ${time.toFixed(1)}s`,
 `üî¥ Active intersections | üü° Recent intersections (fade over 10s)`
 ];
 
 texts.forEach((text, index) =&gt; {
 const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 textElement.setAttribute('x', '20');
 textElement.setAttribute('y', 30 + index * 20);
 textElement.setAttribute('fill', '#fff');
 textElement.setAttribute('font-size', '14');
 textElement.setAttribute('font-family', 'monospace');
 textElement.textContent = text;
 infoGroup.appendChild(textElement);
 });
 
 svg.appendChild(infoGroup);
}

function startAnimation() {
 stopAnimation();
 startTime = 0;
 isAnimating = true;
 persistentIntersections = [];
 initializeSVG();
 animate();
}

function stopAnimation() {
 isAnimating = false;
 if (animationId) {
 cancelAnimationFrame(animationId);
 animationId = null;
 }
}

function togglePaths() {
 showPaths = !showPaths;
 const pathGuides = svg.querySelector('#pathGuides');
 if (pathGuides) {
 pathGuides.setAttribute('opacity', showPaths ? '0.3' : '0');
 }
}

function clearIntersections() {
 persistentIntersections = [];
 updatePersistentIntersectionDisplay();
}

function updateSpeed(value) {
 animationSpeed = parseFloat(value);
 document.getElementById('speedValue').textContent = `${animationSpeed.toFixed(1)}x`;
}

// Initialize
initializeSVG();

// Handle window resize
window.addEventListener('resize', () =&gt; {
 if (isAnimating) {
 stopAnimation();
 setTimeout(() =&gt; {
 startAnimation();
 }, 100);
 } else {
 initializeSVG();
 }
});
&lt;/script&gt;
&lt;h2 id="triangle-circle-intersection-detection"&gt;Triangle-Circle Intersection Detection&lt;/h2&gt;
&lt;h3 id="intersection-algorithm"&gt;&lt;strong&gt;Intersection Algorithm:&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id="1-line-circle-intersection"&gt;1. &lt;strong&gt;Line-Circle Intersection&lt;/strong&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineCircleIntersection&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;lineStart&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;lineEnd&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;circleCenter&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;radius&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Convert to quadratic equation: at¬≤ + bt + c = 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dx&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineEnd&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineStart&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dy&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineEnd&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineStart&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fx&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineStart&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;circleCenter&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fy&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineStart&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;circleCenter&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;a&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dx&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dx&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dy&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dy&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;b&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;fx&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dx&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fy&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dy&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;c&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;fx&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fx&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fy&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fy&lt;/span&gt;) &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;radius&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;radius&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;discriminant&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;b&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;b&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;4&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;a&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;c&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Returns intersection points on triangle edges
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="2-point-in-triangle-test"&gt;2. &lt;strong&gt;Point-in-Triangle Test&lt;/strong&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;pointInTriangle&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;point&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;triangle&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Barycentric coordinate system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Tests if circle center is inside triangle
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;u&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;dot11&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dot02&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dot01&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dot12&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;invDenom&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;v&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;dot00&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dot12&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dot01&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dot02&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;invDenom&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;u&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;) &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;v&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;) &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;u&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;v&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="motion-paths"&gt;&lt;strong&gt;Motion Paths:&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id="triangle-path-large-circle---clockwise"&gt;&lt;strong&gt;Triangle Path (Large Circle - Clockwise)&lt;/strong&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Large circular orbit - triangle moves clockwise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;centerX&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; Math.&lt;span style="color:#a6e22e"&gt;cos&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;time&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;180&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;centerY&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; Math.&lt;span style="color:#a6e22e"&gt;sin&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;time&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;180&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;rotation&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;time&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; Math.&lt;span style="color:#a6e22e"&gt;PI&lt;/span&gt; &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// Points in movement direction
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="circle-path-small-circle---counter-clockwise"&gt;&lt;strong&gt;Circle Path (Small Circle - Counter-clockwise)&lt;/strong&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Smaller, faster circular orbit - circle moves counter-clockwise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;centerX&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; Math.&lt;span style="color:#a6e22e"&gt;cos&lt;/span&gt;(&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;time&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1.5&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;120&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;centerY&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; Math.&lt;span style="color:#a6e22e"&gt;sin&lt;/span&gt;(&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;time&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1.5&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;120&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Opposite direction and 1.5x speed creates regular intersections
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="intersection-visualization"&gt;&lt;strong&gt;Intersection Visualization:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üî¥ Active Intersections&lt;/strong&gt;: Real-time intersection points (pulsing red circles)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üü° Persistent Markers&lt;/strong&gt;: Historical intersection points that fade over 10 seconds&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path Guides&lt;/strong&gt;: Dashed lines showing the movement paths (toggleable)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Live Statistics&lt;/strong&gt;: Current and total intersection counts&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="detection-features"&gt;&lt;strong&gt;Detection Features:&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id="real-time-processing"&gt;&lt;strong&gt;Real-time Processing&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Detects intersections between triangle edges and circle perimeter&lt;/li&gt;
&lt;li&gt;Handles special case when circle center is inside triangle&lt;/li&gt;
&lt;li&gt;Avoids duplicate detection with proximity checking&lt;/li&gt;
&lt;li&gt;Maintains persistent history with automatic cleanup&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="visual-feedback"&gt;&lt;strong&gt;Visual Feedback&lt;/strong&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Current intersections: pulsing animation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;animate&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; document.&lt;span style="color:#a6e22e"&gt;createElementNS&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;http://www.w3.org/2000/svg&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;animate&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;animate&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;setAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;attributeName&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;animate&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;setAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;values&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;8;12;8&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Persistent intersections: fade over time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;opacity&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; Math.&lt;span style="color:#a6e22e"&gt;max&lt;/span&gt;(&lt;span style="color:#ae81ff"&gt;0.1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;age&lt;/span&gt; &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="interactive-controls"&gt;&lt;strong&gt;Interactive Controls:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Start/Stop Animation&lt;/strong&gt;: Control the intersection detection process&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Toggle Paths&lt;/strong&gt;: Show/hide the curved path guides&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clear Points&lt;/strong&gt;: Remove all persistent intersection markers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Speed Control&lt;/strong&gt;: Adjust animation speed from 0.5x to 3x&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mathematical-precision"&gt;&lt;strong&gt;Mathematical Precision:&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id="geometric-algorithms"&gt;&lt;strong&gt;Geometric Algorithms&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Quadratic Formula&lt;/strong&gt;: Precise line-circle intersection calculation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Barycentric Coordinates&lt;/strong&gt;: Accurate point-in-triangle testing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parametric Curves&lt;/strong&gt;: Smooth mathematical motion paths&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Temporal Tracking&lt;/strong&gt;: Time-based intersection history&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This demonstrates advanced geometric intersection detection with real-time visualization, combining mathematical precision with interactive feedback systems!&lt;/p&gt;</description></item><item><title>Line Intersection Detection and Splitting</title><link>https://thetanil.github.io/posts/svg_004/</link><pubDate>Wed, 08 Oct 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/svg_004/</guid><description>&lt;p&gt;This post demonstrates efficient line intersection detection using SVG-optimized techniques, with automatic circle placement and visual line splitting effects.&lt;/p&gt;
&lt;h3 id="intersection-demos"&gt;Intersection Demos:&lt;/h3&gt;
&lt;div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;"&gt;
&lt;button onclick="stopAnimation(); createStaticIntersectionDemo();" style="padding: 10px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;Static Intersections&lt;/button&gt;
&lt;button onclick="stopAnimation(); createInteractiveDemo();" style="padding: 10px 15px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;Interactive Lines&lt;/button&gt;
&lt;button onclick="startAnimation();" style="padding: 10px 15px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;üé¨ Animated Intersections&lt;/button&gt;
&lt;button onclick="stopAnimation()" style="padding: 10px 15px; background: #F44336; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;‚èπÔ∏è Stop Animation&lt;/button&gt;
&lt;/div&gt;
&lt;div id="svg-container" style="width: 100%; height: 100vh; margin: 0; padding: 0; background: #111;"&gt;&lt;/div&gt;
&lt;script&gt;
// SVG-optimized intersection utilities
function bboxIntersect(bbox1, bbox2) {
 return !(bbox1.x + bbox1.width &lt; bbox2.x || 
 bbox2.x + bbox2.width &lt; bbox1.x || 
 bbox1.y + bbox1.height &lt; bbox2.y || 
 bbox2.y + bbox2.height &lt; bbox1.y);
}

function getLineFromElement(line) {
 return {
 x1: parseFloat(line.getAttribute('x1')),
 y1: parseFloat(line.getAttribute('y1')),
 x2: parseFloat(line.getAttribute('x2')),
 y2: parseFloat(line.getAttribute('y2'))
 };
}

function lineIntersection(line1, line2) {
 const x1 = line1.x1, y1 = line1.y1, x2 = line1.x2, y2 = line1.y2;
 const x3 = line2.x1, y3 = line2.y1, x4 = line2.x2, y4 = line2.y2;
 
 const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
 if (Math.abs(denom) &lt; 1e-10) return null; // Parallel lines
 
 const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
 const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
 
 // Check if intersection is within both line segments
 if (t &gt;= 0 &amp;&amp; t &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1) {
 return {
 x: x1 + t * (x2 - x1),
 y: y1 + t * (y2 - y1),
 t1: t,
 t2: u
 };
 }
 
 return null;
}

// Animation and interaction state
let animationId = null;
let isAnimating = false;
let lines = [];
let intersections = [];
let isDragging = false;
let dragTarget = null;
let dragOffset = { x: 0, y: 0 };

function createStaticIntersectionDemo() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', '100%');
 svg.setAttribute('height', 'auto');
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#111';
 
 // Create grid background
 const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
 const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
 pattern.setAttribute('id', 'grid');
 pattern.setAttribute('width', '50');
 pattern.setAttribute('height', '50');
 pattern.setAttribute('patternUnits', 'userSpaceOnUse');
 
 const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
 gridPath.setAttribute('d', 'M 50 0 L 0 0 0 50');
 gridPath.setAttribute('fill', 'none');
 gridPath.setAttribute('stroke', '#333');
 gridPath.setAttribute('stroke-width', '1');
 gridPath.setAttribute('opacity', '0.3');
 
 pattern.appendChild(gridPath);
 defs.appendChild(pattern);
 svg.appendChild(defs);
 
 const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
 gridRect.setAttribute('width', '100%');
 gridRect.setAttribute('height', '100%');
 gridRect.setAttribute('fill', 'url(#grid)');
 svg.appendChild(gridRect);
 
 // Define static lines for demonstration
 const staticLines = [
 { x1: 100, y1: 100, x2: width - 100, y2: height - 100, color: '#ff6b6b' },
 { x1: width - 100, y1: 100, x2: 100, y2: height - 100, color: '#4ecdc4' },
 { x1: width * 0.2, y1: height * 0.8, x2: width * 0.8, y2: height * 0.2, color: '#45b7d1' },
 { x1: width * 0.5, y1: 50, x2: width * 0.5, y2: height - 50, color: '#96ceb4' },
 { x1: 50, y1: height * 0.5, x2: width - 50, y2: height * 0.5, color: '#ffeaa7' }
 ];
 
 // Draw lines
 staticLines.forEach((lineData, index) =&gt; {
 const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 line.setAttribute('x1', lineData.x1);
 line.setAttribute('y1', lineData.y1);
 line.setAttribute('x2', lineData.x2);
 line.setAttribute('y2', lineData.y2);
 line.setAttribute('stroke', lineData.color);
 line.setAttribute('stroke-width', '3');
 line.setAttribute('opacity', '0.8');
 line.setAttribute('id', `line-${index}`);
 svg.appendChild(line);
 });
 
 // Find all intersections
 const lineElements = svg.querySelectorAll('line');
 const foundIntersections = [];
 
 for (let i = 0; i &lt; lineElements.length; i++) {
 for (let j = i + 1; j &lt; lineElements.length; j++) {
 const line1 = getLineFromElement(lineElements[i]);
 const line2 = getLineFromElement(lineElements[j]);
 
 // Quick bounding box check first (SVG optimization)
 const bbox1 = lineElements[i].getBBox();
 const bbox2 = lineElements[j].getBBox();
 
 if (bboxIntersect(bbox1, bbox2)) {
 const intersection = lineIntersection(line1, line2);
 if (intersection) {
 foundIntersections.push({
 ...intersection,
 line1Index: i,
 line2Index: j
 });
 }
 }
 }
 }
 
 // Draw intersection circles
 foundIntersections.forEach((intersection, index) =&gt; {
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', intersection.x);
 circle.setAttribute('cy', intersection.y);
 circle.setAttribute('r', '8');
 circle.setAttribute('fill', '#ff9ff3');
 circle.setAttribute('stroke', '#fff');
 circle.setAttribute('stroke-width', '2');
 circle.setAttribute('opacity', '0.9');
 
 // Add pulsing animation
 const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
 animate.setAttribute('attributeName', 'r');
 animate.setAttribute('values', '8;12;8');
 animate.setAttribute('dur', '2s');
 animate.setAttribute('repeatCount', 'indefinite');
 circle.appendChild(animate);
 
 svg.appendChild(circle);
 
 // Add intersection label
 const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 text.setAttribute('x', intersection.x + 15);
 text.setAttribute('y', intersection.y - 10);
 text.setAttribute('fill', '#fff');
 text.setAttribute('font-size', '12');
 text.setAttribute('font-family', 'monospace');
 text.textContent = `(${Math.round(intersection.x)}, ${Math.round(intersection.y)})`;
 svg.appendChild(text);
 });
 
 // Add intersection count
 const countText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 countText.setAttribute('x', '20');
 countText.setAttribute('y', '30');
 countText.setAttribute('fill', '#fff');
 countText.setAttribute('font-size', '16');
 countText.setAttribute('font-family', 'monospace');
 countText.textContent = `Intersections found: ${foundIntersections.length}`;
 svg.appendChild(countText);
 
 container.appendChild(svg);
}

function createInteractiveDemo() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', '100%');
 svg.setAttribute('height', 'auto');
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#111';
 svg.style.cursor = 'crosshair';
 
 // Initialize draggable lines
 lines = [
 { x1: 200, y1: 200, x2: width - 200, y2: height - 200, color: '#ff6b6b' },
 { x1: width - 200, y1: 200, x2: 200, y2: height - 200, color: '#4ecdc4' },
 { x1: width * 0.3, y1: height * 0.8, x2: width * 0.7, y2: height * 0.2, color: '#45b7d1' }
 ];
 
 function updateDisplay() {
 // Clear previous content
 while (svg.firstChild) {
 svg.removeChild(svg.firstChild);
 }
 
 // Find intersections
 intersections = [];
 for (let i = 0; i &lt; lines.length; i++) {
 for (let j = i + 1; j &lt; lines.length; j++) {
 const intersection = lineIntersection(lines[i], lines[j]);
 if (intersection) {
 intersections.push({
 ...intersection,
 line1: i,
 line2: j
 });
 }
 }
 }
 
 // Draw lines with splitting effect
 lines.forEach((line, index) =&gt; {
 const segments = getLineSplitSegments(line, index);
 
 segments.forEach((segment, segIndex) =&gt; {
 const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 lineEl.setAttribute('x1', segment.x1);
 lineEl.setAttribute('y1', segment.y1);
 lineEl.setAttribute('x2', segment.x2);
 lineEl.setAttribute('y2', segment.y2);
 lineEl.setAttribute('stroke', line.color);
 lineEl.setAttribute('stroke-width', '4');
 lineEl.setAttribute('opacity', segment.isGap ? '0.3' : '0.9');
 lineEl.setAttribute('stroke-dasharray', segment.isGap ? '5,5' : 'none');
 svg.appendChild(lineEl);
 });
 
 // Draw draggable endpoints
 [{ x: line.x1, y: line.y1, type: 'start' }, { x: line.x2, y: line.y2, type: 'end' }].forEach(point =&gt; {
 const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 handle.setAttribute('cx', point.x);
 handle.setAttribute('cy', point.y);
 handle.setAttribute('r', '8');
 handle.setAttribute('fill', line.color);
 handle.setAttribute('stroke', '#fff');
 handle.setAttribute('stroke-width', '2');
 handle.setAttribute('opacity', '0.8');
 handle.style.cursor = 'grab';
 handle.dataset.lineIndex = index;
 handle.dataset.pointType = point.type;
 svg.appendChild(handle);
 });
 });
 
 // Draw intersection circles
 intersections.forEach((intersection, index) =&gt; {
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', intersection.x);
 circle.setAttribute('cy', intersection.y);
 circle.setAttribute('r', '6');
 circle.setAttribute('fill', '#ff9ff3a0');
 circle.setAttribute('stroke', '#ff9ff3');
 circle.setAttribute('stroke-width', '2');
 svg.appendChild(circle);
 });
 
 // Add instruction text
 const instructionText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 instructionText.setAttribute('x', '20');
 instructionText.setAttribute('y', '30');
 instructionText.setAttribute('fill', '#fff');
 instructionText.setAttribute('font-size', '14');
 instructionText.setAttribute('font-family', 'Arial');
 instructionText.textContent = `Drag line endpoints to see intersections update | Intersections: ${intersections.length}`;
 svg.appendChild(instructionText);
 }
 
 function getLineSplitSegments(line, lineIndex) {
 // Find intersections that affect this line
 const relevantIntersections = intersections
 .filter(int =&gt; int.line1 === lineIndex || int.line2 === lineIndex)
 .map(int =&gt; ({
 x: int.x,
 y: int.y,
 t: int.line1 === lineIndex ? int.t1 : int.t2
 }))
 .sort((a, b) =&gt; a.t - b.t);
 
 if (relevantIntersections.length === 0) {
 return [line];
 }
 
 const segments = [];
 let lastT = 0;
 
 relevantIntersections.forEach((intersection, index) =&gt; {
 // Add segment before intersection
 if (intersection.t &gt; lastT) {
 segments.push({
 x1: line.x1 + lastT * (line.x2 - line.x1),
 y1: line.y1 + lastT * (line.y2 - line.y1),
 x2: line.x1 + intersection.t * (line.x2 - line.x1),
 y2: line.y1 + intersection.t * (line.y2 - line.y1),
 isGap: false
 });
 }
 
 // Add gap around intersection
 const gapSize = 0.02;
 const gapStart = Math.max(0, intersection.t - gapSize);
 const gapEnd = Math.min(1, intersection.t + gapSize);
 
 if (gapEnd &lt; 1) {
 segments.push({
 x1: line.x1 + gapStart * (line.x2 - line.x1),
 y1: line.y1 + gapStart * (line.y2 - line.y1),
 x2: line.x1 + gapEnd * (line.x2 - line.x1),
 y2: line.y1 + gapEnd * (line.y2 - line.y1),
 isGap: true
 });
 }
 
 lastT = gapEnd;
 });
 
 // Add final segment
 if (lastT &lt; 1) {
 segments.push({
 x1: line.x1 + lastT * (line.x2 - line.x1),
 y1: line.y1 + lastT * (line.y2 - line.y1),
 x2: line.x2,
 y2: line.y2,
 isGap: false
 });
 }
 
 return segments;
 }
 
 // Mouse event handlers
 svg.addEventListener('mousedown', (e) =&gt; {
 const rect = svg.getBoundingClientRect();
 const x = e.clientX - rect.left;
 const y = e.clientY - rect.top;
 
 // Check if clicking on a handle
 const handle = e.target;
 if (handle.dataset.lineIndex !== undefined) {
 isDragging = true;
 dragTarget = {
 lineIndex: parseInt(handle.dataset.lineIndex),
 pointType: handle.dataset.pointType
 };
 handle.style.cursor = 'grabbing';
 }
 });
 
 svg.addEventListener('mousemove', (e) =&gt; {
 if (!isDragging || !dragTarget) return;
 
 const rect = svg.getBoundingClientRect();
 const x = e.clientX - rect.left;
 const y = e.clientY - rect.top;
 
 const line = lines[dragTarget.lineIndex];
 if (dragTarget.pointType === 'start') {
 line.x1 = x;
 line.y1 = y;
 } else {
 line.x2 = x;
 line.y2 = y;
 }
 
 updateDisplay();
 });
 
 svg.addEventListener('mouseup', () =&gt; {
 isDragging = false;
 dragTarget = null;
 svg.querySelectorAll('circle').forEach(handle =&gt; {
 handle.style.cursor = 'grab';
 });
 });
 
 updateDisplay();
 container.appendChild(svg);
}

function createAnimatedIntersections() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', '100%');
 svg.setAttribute('height', 'auto');
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#111';
 
 function animate() {
 if (!isAnimating) return;
 
 const time = Date.now() * 0.001;
 
 // Clear previous content
 while (svg.firstChild) {
 svg.removeChild(svg.firstChild);
 }
 
 // Create moving lines
 const movingLines = [
 {
 x1: width * 0.1,
 y1: height * 0.5 + Math.sin(time) * height * 0.3,
 x2: width * 0.9,
 y2: height * 0.5 + Math.cos(time * 1.3) * height * 0.3,
 color: '#ff6b6b'
 },
 {
 x1: width * 0.5 + Math.cos(time * 0.7) * width * 0.3,
 y1: height * 0.1,
 x2: width * 0.5 + Math.sin(time * 0.9) * width * 0.3,
 y2: height * 0.9,
 color: '#4ecdc4'
 },
 {
 x1: width * 0.2 + Math.sin(time * 1.1) * width * 0.2,
 y1: height * 0.8,
 x2: width * 0.8 + Math.cos(time * 0.8) * width * 0.2,
 y2: height * 0.2,
 color: '#45b7d1'
 }
 ];
 
 // Draw lines
 movingLines.forEach(line =&gt; {
 const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 lineEl.setAttribute('x1', line.x1);
 lineEl.setAttribute('y1', line.y1);
 lineEl.setAttribute('x2', line.x2);
 lineEl.setAttribute('y2', line.y2);
 lineEl.setAttribute('stroke', line.color);
 lineEl.setAttribute('stroke-width', '3');
 lineEl.setAttribute('opacity', '0.8');
 svg.appendChild(lineEl);
 });
 
 // Find and draw intersections
 const currentIntersections = [];
 for (let i = 0; i &lt; movingLines.length; i++) {
 for (let j = i + 1; j &lt; movingLines.length; j++) {
 const intersection = lineIntersection(movingLines[i], movingLines[j]);
 if (intersection) {
 currentIntersections.push(intersection);
 }
 }
 }
 
 currentIntersections.forEach(intersection =&gt; {
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', intersection.x);
 circle.setAttribute('cy', intersection.y);
 circle.setAttribute('r', '10');
 circle.setAttribute('fill', '#ff9ff3');
 circle.setAttribute('stroke', '#fff');
 circle.setAttribute('stroke-width', '2');
 circle.setAttribute('opacity', '0.9');
 svg.appendChild(circle);
 
 // Add ripple effect
 const ripple = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 ripple.setAttribute('cx', intersection.x);
 ripple.setAttribute('cy', intersection.y);
 ripple.setAttribute('r', '15');
 ripple.setAttribute('fill', 'none');
 ripple.setAttribute('stroke', '#ff9ff3');
 ripple.setAttribute('stroke-width', '1');
 ripple.setAttribute('opacity', '0.5');
 svg.appendChild(ripple);
 });
 
 // Add intersection count
 const countText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
 countText.setAttribute('x', '20');
 countText.setAttribute('y', '30');
 countText.setAttribute('fill', '#fff');
 countText.setAttribute('font-size', '16');
 countText.setAttribute('font-family', 'monospace');
 countText.textContent = `Live Intersections: ${currentIntersections.length}`;
 svg.appendChild(countText);
 
 animationId = requestAnimationFrame(animate);
 }
 
 container.appendChild(svg);
 animate();
}

function startAnimation() {
 isAnimating = true;
 createAnimatedIntersections();
}

function stopAnimation() {
 isAnimating = false;
 if (animationId) {
 cancelAnimationFrame(animationId);
 animationId = null;
 }
}

// Initialize
createStaticIntersectionDemo();

// Handle window resize
window.addEventListener('resize', () =&gt; {
 if (!isAnimating) {
 createStaticIntersectionDemo();
 }
});
&lt;/script&gt;
&lt;h2 id="svg-optimization-techniques"&gt;SVG Optimization Techniques&lt;/h2&gt;
&lt;h3 id="1-bounding-box-pre-filtering"&gt;1. &lt;strong&gt;Bounding Box Pre-filtering&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bboxIntersect&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#f92672"&gt;!&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;width&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;||&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;width&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;||&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;height&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;||&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;height&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;bbox1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;y&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Quick elimination before expensive intersection math
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;bboxIntersect&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;line1&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getBBox&lt;/span&gt;(), &lt;span style="color:#a6e22e"&gt;line2&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getBBox&lt;/span&gt;())) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Only then do precise intersection calculation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="2-svg-coordinate-extraction"&gt;2. &lt;strong&gt;SVG Coordinate Extraction&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;getLineFromElement&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;x1&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; parseFloat(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;x1&amp;#39;&lt;/span&gt;)),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;y1&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; parseFloat(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;y1&amp;#39;&lt;/span&gt;)),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;x2&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; parseFloat(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;x2&amp;#39;&lt;/span&gt;)),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;y2&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; parseFloat(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getAttribute&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;y2&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="3-visual-line-splitting"&gt;3. &lt;strong&gt;Visual Line Splitting&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;getLineSplitSegments&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;line&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;intersections&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Creates visual gaps at intersection points
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// More efficient than creating separate path elements
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;segments&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; [];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;intersections&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;forEach&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;intersection&lt;/span&gt; =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Add gap around intersection point
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;gapSize&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.02&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 2% of line length
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Split line into segments with gaps
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;segments&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="4-efficient-intersection-algorithm"&gt;4. &lt;strong&gt;Efficient Intersection Algorithm&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;lineIntersection&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;line1&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;line2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Parametric line intersection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Returns null for parallel lines (early exit)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Checks if intersection is within line segments
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// Returns intersection point with parameter values
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="performance-features"&gt;Performance Features&lt;/h2&gt;
&lt;h3 id="optimization-strategies"&gt;&lt;strong&gt;Optimization Strategies:&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Bounding Box Testing&lt;/strong&gt;: Quick elimination of non-intersecting line pairs&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SVG Native Coordinates&lt;/strong&gt;: Direct attribute access without transformations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parametric Intersection&lt;/strong&gt;: Mathematical precision with early exits&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visual Effects&lt;/strong&gt;: Line splitting and gap rendering&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Real-time Updates&lt;/strong&gt;: Efficient redraw strategies&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="interactive-features"&gt;&lt;strong&gt;Interactive Features:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Draggable Endpoints&lt;/strong&gt;: Move line endpoints to see live intersection updates&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visual Splitting&lt;/strong&gt;: Lines break at intersection points with dashed gaps&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Real-time Counting&lt;/strong&gt;: Dynamic intersection count display&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smooth Animation&lt;/strong&gt;: Moving lines with continuous intersection detection&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="svg-specific-benefits"&gt;&lt;strong&gt;SVG-Specific Benefits:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Direct Coordinate Access&lt;/strong&gt;: &lt;code&gt;getAttribute()&lt;/code&gt; for line positions&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Built-in Bounding Boxes&lt;/strong&gt;: &lt;code&gt;getBBox()&lt;/code&gt; for quick spatial queries&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Native Rendering&lt;/strong&gt;: Hardware-accelerated line and circle drawing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event Integration&lt;/strong&gt;: Mouse events directly on SVG elements&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This system demonstrates how SVG&amp;rsquo;s built-in features can optimize geometric calculations and provide smooth interactive experiences!&lt;/p&gt;</description></item></channel></rss>