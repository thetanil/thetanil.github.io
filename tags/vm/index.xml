<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vm on Theta Nil's Site</title><link>https://thetanil.github.io/tags/vm/</link><description>Recent content in Vm on Theta Nil's Site</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 25 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://thetanil.github.io/tags/vm/index.xml" rel="self" type="application/rss+xml"/><item><title>Theta-lang: Core Design Decisions</title><link>https://thetanil.github.io/posts/theta-lang-design-decisions/</link><pubDate>Tue, 25 Nov 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/theta-lang-design-decisions/</guid><description>&lt;h2 id="ratified-design-choices"&gt;Ratified Design Choices&lt;/h2&gt;
&lt;p&gt;These fundamental design decisions have been confirmed and should guide all implementation work.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-memory-model-arena-allocation"&gt;1. Memory Model: Arena Allocation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Decision:&lt;/strong&gt; Use arena-based memory allocation for FlatBuffer regions.&lt;/p&gt;
&lt;h3 id="rationale"&gt;Rationale&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Perfect fit with FlatBuffers:&lt;/strong&gt; Append-only FlatBuffer building aligns naturally with arena allocation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Predictable lifecycle:&lt;/strong&gt; Entire arena can be freed at once when a computation completes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zero fragmentation:&lt;/strong&gt; Sequential allocation eliminates memory fragmentation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fast allocation:&lt;/strong&gt; Bump-pointer allocation is O(1)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Immutability enforcement:&lt;/strong&gt; Once built, FlatBuffer regions are immutable - arenas reinforce this&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="implementation-implications"&gt;Implementation Implications&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;VM maintains multiple arenas for different buffer generations&lt;/li&gt;
&lt;li&gt;Each major computation phase (loading module, executing function, materializing dataflow result) gets its own arena&lt;/li&gt;
&lt;li&gt;Host can retain references to old arenas even after VM creates new ones&lt;/li&gt;
&lt;li&gt;Cleanup is simple: drop entire arena when no references remain&lt;/li&gt;
&lt;li&gt;No need for garbage collection or reference counting within an arena&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="memory-layout-strategy"&gt;Memory Layout Strategy&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Arena 1: Program module (immutable, lives for VM lifetime)
Arena 2: Execution state generation N (replaced on each instruction batch)
Arena 3: Dataflow intermediate results (replaced on materialization)
Arena 4: Final results (retained by host, freed when host releases)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id="2-register-architecture-typed-registers"&gt;2. Register Architecture: Typed Registers&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Decision:&lt;/strong&gt; Registers are statically typed; type checking occurs at module load time.&lt;/p&gt;</description></item><item><title>Theta-lang: Developer Feedback</title><link>https://thetanil.github.io/posts/theta-lang-feedback/</link><pubDate>Tue, 25 Nov 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/theta-lang-feedback/</guid><description>&lt;h2 id="questions-for-design-validation-and-implementation-guidance"&gt;Questions for Design Validation and Implementation Guidance&lt;/h2&gt;
&lt;p&gt;As the developer tasked with implementing the Theta VM, I need clarification on several aspects of the design to ensure correct implementation and avoid costly refactoring. These questions are organized by architectural concern.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-flatbuffer-schema-design-and-evolution"&gt;1. FlatBuffer Schema Design and Evolution&lt;/h2&gt;
&lt;h3 id="11-schema-versioning-strategy"&gt;1.1 Schema Versioning Strategy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; How should schema evolution be handled when the VM state structure changes between releases?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Should we use FlatBuffers&amp;rsquo; built-in schema evolution (adding optional fields)?&lt;/li&gt;
&lt;li&gt;Do we need explicit version tags in each root table?&lt;/li&gt;
&lt;li&gt;How should we handle incompatible changes (e.g., removing required fields)?&lt;/li&gt;
&lt;li&gt;Should old VM states be forward-convertible, or is it acceptable to reject incompatible versions?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="12-nested-vs-flat-table-design"&gt;1.2 Nested vs. Flat Table Design&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; How deeply should we nest FlatBuffer tables?&lt;/p&gt;</description></item><item><title>Theta-lang: Feedback Recommendations</title><link>https://thetanil.github.io/posts/theta-lang-recommendation/</link><pubDate>Tue, 25 Nov 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/theta-lang-recommendation/</guid><description>&lt;p&gt;This document summarizes recommendations for several foundational design questions, with pros and cons for each option. These are based on the design and implementation plan for the Theta VM.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-schema-organization-one-big-fbs-file-vs-multiple-files"&gt;1. Schema Organization: One Big .fbs File vs. Multiple Files&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Recommendation:&lt;/strong&gt; Use multiple .fbs files, organized by subsystem (types, memory, values, instructions, program, execution, operators, dataflow, tables, integration, stdlib).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pros:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Easier to maintain and evolve schemas independently&lt;/li&gt;
&lt;li&gt;Clear separation of concerns; reduces merge conflicts&lt;/li&gt;
&lt;li&gt;Enables targeted regeneration of bindings&lt;/li&gt;
&lt;li&gt;Facilitates schema versioning and compatibility&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Cons:&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Theta-lang: Implementation Plan: FlatBuffer-Backed Procedural Dataflow VM</title><link>https://thetanil.github.io/posts/theta-lang-implementation/</link><pubDate>Tue, 25 Nov 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/theta-lang-implementation/</guid><description>&lt;h2 id="project-theta-virtual-machine"&gt;Project: Theta Virtual Machine&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Target Language:&lt;/strong&gt; C11
&lt;strong&gt;Architecture:&lt;/strong&gt; Three-layer VM with procedural execution, dataflow engine, and FlatBuffer-backed shared memory&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Core Design Decisions:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory Model:&lt;/strong&gt; Arena allocation with bump-pointer allocators&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Register Architecture:&lt;/strong&gt; 256 typed registers (r0-r255)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Language:&lt;/strong&gt; Statically typed, C-like procedural language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Storage:&lt;/strong&gt; Columnar table layout with typed columns&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Execution:&lt;/strong&gt; Pull-based lazy evaluation with DAG interpreter&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="phase-1-foundation---flatbuffers-schema-definition"&gt;Phase 1: Foundation - FlatBuffers Schema Definition&lt;/h2&gt;
&lt;h3 id="11-core-type-system-schema"&gt;1.1 Core Type System Schema&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Define primitive type enumeration (i8, i16, i32, i64, f32, f64, bool, string)&lt;/li&gt;
&lt;li&gt;Define reference types (ptr, table_ref, node_ref)&lt;/li&gt;
&lt;li&gt;Create type descriptor tables with nullability, stride, and alignment metadata&lt;/li&gt;
&lt;li&gt;Design schema versioning strategy&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="12-memory-layout-schema-arena-based"&gt;1.2 Memory Layout Schema (Arena-Based)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Define Arena table (base pointer, current offset, capacity, generation ID)&lt;/li&gt;
&lt;li&gt;Define ArenaPool table for managing multiple arena generations&lt;/li&gt;
&lt;li&gt;Create buffer metadata (arena reference, offset, size)&lt;/li&gt;
&lt;li&gt;Design arena lifecycle tracking (creation, active, retired, freed)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="13-value-representation-schema"&gt;1.3 Value Representation Schema&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Define Value union type (scalar, table reference, dataflow node reference)&lt;/li&gt;
&lt;li&gt;Create ScalarValue table (type tag, raw bytes)&lt;/li&gt;
&lt;li&gt;Design TableValue table (schema reference, row count, column references)&lt;/li&gt;
&lt;li&gt;Define DataflowNodeReference (node ID, output port)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="14-schema-evolution-strategy"&gt;1.4 Schema Evolution Strategy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Implement schema version numbering&lt;/li&gt;
&lt;li&gt;Design backward compatibility layer for schema changes&lt;/li&gt;
&lt;li&gt;Create validation utilities for schema conformance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Deliverables:&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Theta-lang: VM Design and Implementation</title><link>https://thetanil.github.io/posts/theta-lang-vm/</link><pubDate>Tue, 25 Nov 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/theta-lang-vm/</guid><description>&lt;h1 id="theta-lang-vm-design-and-implementation"&gt;Theta-lang: VM Design and Implementation&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://thetanil.github.io/posts/theta-lang-design-decisions/"&gt;Design Decisions&lt;/a&gt;
&lt;a href="https://thetanil.github.io/posts/theta-lang-implementation/"&gt;Implementation Plan&lt;/a&gt;
&lt;a href="https://thetanil.github.io/posts/theta-lang-feedback/"&gt;Developer Feedback &amp;amp; Questions&lt;/a&gt;
&lt;a href="https://thetanil.github.io/posts/theta-lang-recommendation/"&gt;Recommendations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This page consolidates all technical documentation, design decisions, implementation plans, developer feedback, and recommendations for the theta-lang virtual machine project. The content below is organized into major sections for clarity. Subpages may be created for deeper dives if needed.&lt;/p&gt;
&lt;h2 id="1-overview"&gt;1. Overview&lt;/h2&gt;
&lt;p&gt;Theta-lang is a new virtual machine (VM) designed for embeddable, high-performance procedural and dataflow computation, with all runtime state and data represented using FlatBuffers. The VM is intended to be host-friendly, introspectable, and suitable for analytics, scripting, and integration with C, Rust, Python, and Go.&lt;/p&gt;</description></item></channel></rss>