<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Svg on Theta Nil's Site</title><link>https://thetanil.github.io/tags/svg/</link><description>Recent content in Svg on Theta Nil's Site</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 08 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://thetanil.github.io/tags/svg/index.xml" rel="self" type="application/rss+xml"/><item><title>SVG Shape Example</title><link>https://thetanil.github.io/posts/svg_001/</link><pubDate>Wed, 08 Oct 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/svg_001/</guid><description>&lt;h1 id="svg-shape-display"&gt;SVG Shape Display&lt;/h1&gt;
&lt;p&gt;Here&amp;rsquo;s an example of displaying SVG shapes directly in a Hugo markdown post.&lt;/p&gt;
&lt;h2 id="inline-svg-example"&gt;Inline SVG Example&lt;/h2&gt;
&lt;p&gt;You can embed SVG directly in your markdown:&lt;/p&gt;
&lt;svg width="200" height="200" xmlns="http://www.w3.org/2000/svg"&gt;
 &lt;!-- Circle --&gt;
 &lt;circle cx="50" cy="50" r="40" fill="blue" stroke="navy" stroke-width="2"/&gt;
 &lt;!-- Rectangle --&gt;
 &lt;rect x="100" y="20" width="60" height="40" fill="red" stroke="darkred" stroke-width="2"/&gt;
 &lt;!-- Triangle (using polygon) --&gt;
 &lt;polygon points="130,100 160,160 100,160" fill="green" stroke="darkgreen" stroke-width="2"/&gt;
 &lt;!-- Line --&gt;
 &lt;line x1="20" y1="120" x2="80" y2="180" stroke="purple" stroke-width="3"/&gt;
 &lt;!-- Text --&gt;
&lt;p&gt;&lt;text x="10" y="190" font-family="Arial" font-size="14" fill="black"&gt;SVG Shapes&lt;/text&gt;
&lt;/svg&gt;&lt;/p&gt;
&lt;h2 id="styled-svg-with-css"&gt;Styled SVG with CSS&lt;/h2&gt;
&lt;p&gt;You can also style SVG elements with CSS:&lt;/p&gt;</description></item><item><title>SVG with Normalized Coordinates</title><link>https://thetanil.github.io/posts/svg_002/</link><pubDate>Wed, 08 Oct 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/svg_002/</guid><description>&lt;p&gt;This post demonstrates how to generate SVG content with JavaScript using normalized coordinates (-1 to 1) similar to fragment shaders.&lt;/p&gt;
&lt;div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;"&gt;
&lt;button onclick="startFragmentAnimation()" style="padding: 10px 15px; background: #8BC34A; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 150px;"&gt;üé¨ Animate Fragment Shader&lt;/button&gt;
&lt;button onclick="startCircleAnimation()" style="padding: 10px 15px; background: #03A9F4; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 150px;"&gt;üé¨ Animate Circles&lt;/button&gt;
&lt;button onclick="stopAnimation()" style="padding: 10px 15px; background: #F44336; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;‚èπÔ∏è Stop Animation&lt;/button&gt;
&lt;/div&gt;
&lt;div id="svg-container" style="width: 100%; height: 100vh; margin: 0; padding: 0;"&gt;&lt;/div&gt;
&lt;script&gt;
// Fragment shader-like functions
function length(x, y) {
 return Math.sqrt(x * x + y * y);
}

function mix(a, b, t) {
 return a * (1 - t) + b * t;
}

function smoothstep(edge0, edge1, x) {
 const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
 return t * t * (3 - 2 * t);
}

function fract(x) {
 return x - Math.floor(x);
}

function sin(x) {
 return Math.sin(x);
}

function cos(x) {
 return Math.cos(x);
}

// Convert normalized coordinates (-1 to 1) to SVG coordinates
function normToSvg(nx, ny, width, height) {
 const x = (nx + 1) * width * 0.5;
 const y = (-ny + 1) * height * 0.5; // Flip Y for SVG coordinate system
 return { x, y };
}

// Convert color components (0-1) to RGB string
function colorToRgb(r, g, b, a = 1) {
 return `rgba(${Math.floor(r * 255)}, ${Math.floor(g * 255)}, ${Math.floor(b * 255)}, ${a})`;
}

// Create a fragment shader-like pattern
function fragmentShader(nx, ny, time) {
 // Distance from center
 const dist = length(nx, ny);
 
 // Angle
 const angle = Math.atan2(ny, nx);
 
 // Create some patterns
 const rings = sin(dist * 10 - time * 2) * 0.5 + 0.5;
 const spiral = sin(angle * 8 + dist * 20 - time * 3) * 0.5 + 0.5;
 const waves = sin(nx * 10 + time) * sin(ny * 10 + time) * 0.5 + 0.5;
 
 // Combine patterns
 const r = rings * 0.8 + 0.2;
 const g = spiral * 0.6 + 0.4;
 const b = waves * 0.9 + 0.1;
 
 return { r, g, b };
}

function createSVGPattern() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 // Create SVG element
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 
 // Resolution for the pattern (adjust for performance vs quality)
 const resolution = 100;
 const pixelWidth = width / resolution;
 const pixelHeight = height / resolution;
 
 // Get current time for animation
 const time = Date.now() * 0.001;
 
 // Generate pattern
 for (let i = 0; i &lt; resolution; i++) {
 for (let j = 0; j &lt; resolution; j++) {
 // Convert to normalized coordinates (-1 to 1)
 const nx = (i / resolution) * 2 - 1;
 const ny = (j / resolution) * 2 - 1;
 
 // Get color from fragment shader
 const color = fragmentShader(nx, ny, time);
 
 // Create rectangle for this "pixel"
 const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
 rect.setAttribute('x', i * pixelWidth);
 rect.setAttribute('y', j * pixelHeight);
 rect.setAttribute('width', pixelWidth);
 rect.setAttribute('height', pixelHeight);
 rect.setAttribute('fill', colorToRgb(color.r, color.g, color.b));
 
 svg.appendChild(rect);
 }
 }
 
 // Clear container and add SVG
 container.innerHTML = '';
 container.appendChild(svg);
}

// Higher resolution example with circles
function createHighResPattern() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 
 const time = Date.now() * 0.001;
 const numCircles = 50;
 
 // Create animated circles using normalized coordinates
 for (let i = 0; i &lt; numCircles; i++) {
 const t = i / numCircles;
 
 // Use normalized coordinates for positioning
 const nx = sin(time + t * Math.PI * 2) * 0.8;
 const ny = cos(time * 1.3 + t * Math.PI * 2) * 0.8;
 
 // Convert to SVG coordinates
 const pos = normToSvg(nx, ny, width, height);
 
 // Create circle
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', pos.x);
 circle.setAttribute('cy', pos.y);
 circle.setAttribute('r', 10 + sin(time * 2 + t * 10) * 5);
 
 // Color based on normalized position
 const dist = length(nx, ny);
 const hue = (t * 360 + time * 50) % 360;
 circle.setAttribute('fill', `hsl(${hue}, 70%, ${60 + dist * 40}%)`);
 circle.setAttribute('opacity', 0.7);
 
 svg.appendChild(circle);
 }
 
 container.innerHTML = '';
 container.appendChild(svg);
}

// Mandelbrot-like pattern using normalized coordinates
function createMandelbrotPattern() {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 
 const resolution = 200;
 const pixelWidth = width / resolution;
 const pixelHeight = height / resolution;
 
 // Mandelbrot-like iteration
 function mandelbrot(cx, cy, maxIter = 20) {
 let x = 0, y = 0;
 let iter = 0;
 
 while (x * x + y * y &lt;= 4 &amp;&amp; iter &lt; maxIter) {
 const temp = x * x - y * y + cx;
 y = 2 * x * y + cy;
 x = temp;
 iter++;
 }
 
 return iter / maxIter;
 }
 
 for (let i = 0; i &lt; resolution; i++) {
 for (let j = 0; j &lt; resolution; j++) {
 // Normalized coordinates
 const nx = (i / resolution) * 3 - 1.5; // Zoom into interesting area
 const ny = (j / resolution) * 3 - 1.5;
 
 const value = mandelbrot(nx, ny);
 
 const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
 rect.setAttribute('x', i * pixelWidth);
 rect.setAttribute('y', j * pixelHeight);
 rect.setAttribute('width', pixelWidth);
 rect.setAttribute('height', pixelHeight);
 
 // Color mapping
 const hue = value * 360 + 200;
 const sat = value &gt; 0.95 ? 0 : 70;
 const light = value * 60 + 20;
 rect.setAttribute('fill', `hsl(${hue}, ${sat}%, ${light}%)`);
 
 svg.appendChild(rect);
 }
 }
 
 container.innerHTML = '';
 container.appendChild(svg);
}

// Animation state
let animationId = null;
let currentPattern = 'static';

// Initialize with pattern
createSVGPattern();

// Animation loops for different patterns
function animateFragmentShader() {
 if (currentPattern === 'fragment') {
 createSVGPattern();
 animationId = requestAnimationFrame(animateFragmentShader);
 }
}

function animateCircles() {
 if (currentPattern === 'circles') {
 createHighResPattern();
 animationId = requestAnimationFrame(animateCircles);
 }
}

function stopAnimation() {
 if (animationId) {
 cancelAnimationFrame(animationId);
 animationId = null;
 }
 currentPattern = 'static';
}

function startFragmentAnimation() {
 stopAnimation();
 currentPattern = 'fragment';
 animateFragmentShader();
}

function startCircleAnimation() {
 stopAnimation();
 currentPattern = 'circles';
 animateCircles();
}

// Handle window resize
window.addEventListener('resize', () =&gt; {
 if (currentPattern === 'static') {
 createSVGPattern();
 }
 // Animation will continue with the current pattern
});
&lt;/script&gt;
&lt;h2 id="key-concepts"&gt;Key Concepts&lt;/h2&gt;
&lt;h3 id="normalized-coordinates"&gt;Normalized Coordinates&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Convert screen position to normalized coordinates (-1 to 1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;i&lt;/span&gt; &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;resolution&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;j&lt;/span&gt; &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;resolution&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Convert normalized coordinates back to SVG coordinates
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;normToSvg&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;width&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;height&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;width&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;height&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// Flip Y for SVG
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; { &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="fragment-shader-like-functions"&gt;Fragment Shader-like Functions&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fragmentShader&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;time&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dist&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;length&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;angle&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; Math.&lt;span style="color:#a6e22e"&gt;atan2&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;ny&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;nx&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;rings&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;sin&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;dist&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;time&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;spiral&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;sin&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;angle&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;8&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dist&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;20&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;time&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;3&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; { &lt;span style="color:#a6e22e"&gt;r&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;rings&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;g&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;spiral&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;b&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0.8&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="performance-considerations"&gt;Performance Considerations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Resolution&lt;/strong&gt;: Lower resolution = better performance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Animation&lt;/strong&gt;: Use &lt;code&gt;requestAnimationFrame&lt;/code&gt; for smooth animation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Batch Operations&lt;/strong&gt;: Create all elements before adding to DOM&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consider Canvas&lt;/strong&gt;: For very high-resolution patterns, HTML5 Canvas might be more efficient&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="advanced-techniques"&gt;Advanced Techniques&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Use viewBox&lt;/strong&gt;: Define custom coordinate systems&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Float Precision&lt;/strong&gt;: JavaScript numbers are 64-bit floats, perfect for shader-like calculations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color Spaces&lt;/strong&gt;: Convert between HSL, RGB, and normalized color values&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time-based Animation&lt;/strong&gt;: Use timestamps for consistent animation speed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interactive&lt;/strong&gt;: Add mouse/touch events for interactive experiences&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This approach gives you the flexibility of fragment shaders with the scalability and styling capabilities of SVG!&lt;/p&gt;</description></item><item><title>Wireframe Box Animation</title><link>https://thetanil.github.io/posts/svg_003/</link><pubDate>Wed, 08 Oct 2025 00:00:00 +0000</pubDate><guid>https://thetanil.github.io/posts/svg_003/</guid><description>&lt;p&gt;This post demonstrates a 3D wireframe cube animation using JavaScript-generated SVG with normalized coordinates and matrix transformations.&lt;/p&gt;
&lt;h3 id="animated-wireframes"&gt;Animated Wireframes:&lt;/h3&gt;
&lt;div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;"&gt;
&lt;button onclick="startAnimation('single')" style="padding: 10px 15px; background: #8BC34A; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 150px;"&gt;üé¨ Rotating Box&lt;/button&gt;
&lt;button onclick="startAnimation('multiple')" style="padding: 10px 15px; background: #03A9F4; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 150px;"&gt;üé¨ Multiple Boxes&lt;/button&gt;
&lt;button onclick="startAnimation('tunnel')" style="padding: 10px 15px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 150px;"&gt;üé¨ Tunnel Animation&lt;/button&gt;
&lt;button onclick="stopAnimation()" style="padding: 10px 15px; background: #F44336; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;"&gt;‚èπÔ∏è Stop Animation&lt;/button&gt;
&lt;/div&gt;
&lt;div id="svg-container" style="width: 100%; height: 100vh; margin: 0; padding: 0; background: #000;"&gt;&lt;/div&gt;
&lt;script&gt;
// 3D Math utilities
function multiply4x4(a, b) {
 const result = new Array(16);
 for (let i = 0; i &lt; 4; i++) {
 for (let j = 0; j &lt; 4; j++) {
 result[i * 4 + j] = 0;
 for (let k = 0; k &lt; 4; k++) {
 result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
 }
 }
 }
 return result;
}

function rotationX(angle) {
 const c = Math.cos(angle);
 const s = Math.sin(angle);
 return [
 1, 0, 0, 0,
 0, c, -s, 0,
 0, s, c, 0,
 0, 0, 0, 1
 ];
}

function rotationY(angle) {
 const c = Math.cos(angle);
 const s = Math.sin(angle);
 return [
 c, 0, s, 0,
 0, 1, 0, 0,
 -s, 0, c, 0,
 0, 0, 0, 1
 ];
}

function rotationZ(angle) {
 const c = Math.cos(angle);
 const s = Math.sin(angle);
 return [
 c, -s, 0, 0,
 s, c, 0, 0,
 0, 0, 1, 0,
 0, 0, 0, 1
 ];
}

function perspective(fov, aspect, near, far) {
 const f = 1.0 / Math.tan(fov / 2);
 return [
 f / aspect, 0, 0, 0,
 0, f, 0, 0,
 0, 0, (far + near) / (near - far), (2 * far * near) / (near - far),
 0, 0, -1, 0
 ];
}

function transformPoint(matrix, x, y, z) {
 const w = matrix[12] * x + matrix[13] * y + matrix[14] * z + matrix[15];
 return {
 x: (matrix[0] * x + matrix[1] * y + matrix[2] * z + matrix[3]) / w,
 y: (matrix[4] * x + matrix[5] * y + matrix[6] * z + matrix[7]) / w,
 z: (matrix[8] * x + matrix[9] * y + matrix[10] * z + matrix[11]) / w
 };
}

// Convert normalized coordinates to SVG coordinates
function normToSvg(nx, ny, width, height) {
 const x = (nx + 1) * width * 0.5;
 const y = (-ny + 1) * height * 0.5;
 return { x, y };
}

// Define cube vertices (normalized coordinates -1 to 1)
const cubeVertices = [
 // Front face
 [-1, -1, 1], [ 1, -1, 1], [ 1, 1, 1], [-1, 1, 1],
 // Back face
 [-1, -1, -1], [ 1, -1, -1], [ 1, 1, -1], [-1, 1, -1]
];

// Define cube edges (vertex indices)
const cubeEdges = [
 // Front face
 [0, 1], [1, 2], [2, 3], [3, 0],
 // Back face
 [4, 5], [5, 6], [6, 7], [7, 4],
 // Connecting edges
 [0, 4], [1, 5], [2, 6], [3, 7]
];

// Animation state
let animationId = null;
let isAnimating = false;

function createWireframeBox(time = 0) {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 // Clear previous content
 container.innerHTML = '';
 
 // Create SVG element
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#000';
 
 // Create transformation matrix
 const rotX = rotationX(time * 0.001);
 const rotY = rotationY(time * 0.0013);
 const rotZ = rotationZ(time * 0.0007);
 
 // Combine rotations
 let transform = multiply4x4(rotX, rotY);
 transform = multiply4x4(transform, rotZ);
 
 // Add perspective
 const proj = perspective(Math.PI / 4, width / height, 0.1, 100);
 
 // Move cube back for perspective
 const translation = [
 1, 0, 0, 0,
 0, 1, 0, 0,
 0, 0, 1, -5,
 0, 0, 0, 1
 ];
 
 transform = multiply4x4(translation, transform);
 const finalTransform = multiply4x4(proj, transform);
 
 // Transform vertices
 const transformedVertices = cubeVertices.map(vertex =&gt; {
 const transformed = transformPoint(finalTransform, vertex[0], vertex[1], vertex[2]);
 return normToSvg(transformed.x, transformed.y, width, height);
 });
 
 // Draw edges
 cubeEdges.forEach((edge, index) =&gt; {
 const start = transformedVertices[edge[0]];
 const end = transformedVertices[edge[1]];
 
 // Skip if behind camera (simple culling)
 if (!start || !end) return;
 
 const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 line.setAttribute('x1', start.x);
 line.setAttribute('y1', start.y);
 line.setAttribute('x2', end.x);
 line.setAttribute('y2', end.y);
 line.setAttribute('stroke', `hsl(${(index * 30 + time * 0.01) % 360}, 70%, 60%)`);
 line.setAttribute('stroke-width', 2);
 line.setAttribute('opacity', 0.8);
 
 svg.appendChild(line);
 });
 
 // Draw vertices
 transformedVertices.forEach((vertex, index) =&gt; {
 if (!vertex) return;
 
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', vertex.x);
 circle.setAttribute('cy', vertex.y);
 circle.setAttribute('r', 4);
 circle.setAttribute('fill', `hsl(${(index * 45 + time * 0.02) % 360}, 80%, 70%)`);
 circle.setAttribute('opacity', 0.9);
 
 svg.appendChild(circle);
 });
 
 container.appendChild(svg);
}

function createMultipleBoxes(time = 0) {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#000';
 
 // Create multiple boxes
 const numBoxes = 5;
 for (let boxIndex = 0; boxIndex &lt; numBoxes; boxIndex++) {
 const scale = 0.3 + (boxIndex * 0.15);
 const offsetX = Math.sin(time * 0.0005 + boxIndex) * 2;
 const offsetY = Math.cos(time * 0.0007 + boxIndex) * 1.5;
 const offsetZ = -3 - boxIndex * 2;
 
 // Create transformation matrix for this box
 const rotX = rotationX(time * 0.001 + boxIndex);
 const rotY = rotationY(time * 0.0013 + boxIndex * 0.5);
 const rotZ = rotationZ(time * 0.0007 + boxIndex * 0.3);
 
 let transform = multiply4x4(rotX, rotY);
 transform = multiply4x4(transform, rotZ);
 
 // Scale and translate
 const scaleMatrix = [
 scale, 0, 0, offsetX,
 0, scale, 0, offsetY,
 0, 0, scale, offsetZ,
 0, 0, 0, 1
 ];
 
 transform = multiply4x4(scaleMatrix, transform);
 
 // Add perspective
 const proj = perspective(Math.PI / 4, width / height, 0.1, 100);
 const finalTransform = multiply4x4(proj, transform);
 
 // Transform vertices
 const transformedVertices = cubeVertices.map(vertex =&gt; {
 const transformed = transformPoint(finalTransform, vertex[0], vertex[1], vertex[2]);
 return normToSvg(transformed.x, transformed.y, width, height);
 });
 
 // Draw edges
 cubeEdges.forEach((edge, edgeIndex) =&gt; {
 const start = transformedVertices[edge[0]];
 const end = transformedVertices[edge[1]];
 
 if (!start || !end) return;
 
 const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 line.setAttribute('x1', start.x);
 line.setAttribute('y1', start.y);
 line.setAttribute('x2', end.x);
 line.setAttribute('y2', end.y);
 line.setAttribute('stroke', `hsl(${(boxIndex * 60 + edgeIndex * 10 + time * 0.01) % 360}, 70%, 60%)`);
 line.setAttribute('stroke-width', 1.5);
 line.setAttribute('opacity', 0.7 - (boxIndex * 0.1));
 
 svg.appendChild(line);
 });
 
 // Draw vertices
 transformedVertices.forEach((vertex, vertexIndex) =&gt; {
 if (!vertex) return;
 
 const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
 circle.setAttribute('cx', vertex.x);
 circle.setAttribute('cy', vertex.y);
 circle.setAttribute('r', 2 + scale);
 circle.setAttribute('fill', `hsl(${(boxIndex * 72 + vertexIndex * 20 + time * 0.02) % 360}, 80%, 70%)`);
 circle.setAttribute('opacity', 0.8 - (boxIndex * 0.1));
 
 svg.appendChild(circle);
 });
 }
 
 container.appendChild(svg);
}

function createTunnelEffect(time = 0) {
 const container = document.getElementById('svg-container');
 const width = window.innerWidth;
 const height = window.innerHeight;
 
 container.innerHTML = '';
 
 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 svg.setAttribute('width', width);
 svg.setAttribute('height', height);
 svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
 svg.style.display = 'block';
 svg.style.background = '#000';
 
 // Create tunnel of boxes
 const numBoxes = 20;
 for (let i = 0; i &lt; numBoxes; i++) {
 const z = -i * 3 - (time * 0.005) % 3;
 if (z &gt; 5) continue; // Don't draw boxes that are too close
 
 const scale = Math.max(0.1, 1 / (Math.abs(z) + 1));
 const rotation = time * 0.001 + i * 0.2;
 
 // Create transformation matrix
 const rotZ = rotationZ(rotation);
 
 const translation = [
 scale, 0, 0, 0,
 0, scale, 0, 0,
 0, 0, scale, z,
 0, 0, 0, 1
 ];
 
 const transform = multiply4x4(translation, rotZ);
 const proj = perspective(Math.PI / 3, width / height, 0.1, 100);
 const finalTransform = multiply4x4(proj, transform);
 
 // Transform vertices
 const transformedVertices = cubeVertices.map(vertex =&gt; {
 const transformed = transformPoint(finalTransform, vertex[0], vertex[1], vertex[2]);
 return normToSvg(transformed.x, transformed.y, width, height);
 });
 
 // Draw edges
 cubeEdges.forEach((edge, edgeIndex) =&gt; {
 const start = transformedVertices[edge[0]];
 const end = transformedVertices[edge[1]];
 
 if (!start || !end) return;
 
 const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
 line.setAttribute('x1', start.x);
 line.setAttribute('y1', start.y);
 line.setAttribute('x2', end.x);
 line.setAttribute('y2', end.y);
 line.setAttribute('stroke', `hsl(${(i * 20 + time * 0.05) % 360}, 70%, ${70 - i * 2}%)`);
 line.setAttribute('stroke-width', Math.max(0.5, scale * 2));
 line.setAttribute('opacity', Math.max(0.1, scale));
 
 svg.appendChild(line);
 });
 }
 
 container.appendChild(svg);
}

// Animation functions
function animateSingleBox() {
 if (!isAnimating) return;
 const time = Date.now();
 createWireframeBox(time);
 animationId = requestAnimationFrame(animateSingleBox);
}

function animateMultipleBoxes() {
 if (!isAnimating) return;
 const time = Date.now();
 createMultipleBoxes(time);
 animationId = requestAnimationFrame(animateMultipleBoxes);
}

function animateTunnel() {
 if (!isAnimating) return;
 const time = Date.now();
 createTunnelEffect(time);
 animationId = requestAnimationFrame(animateTunnel);
}

function startAnimation(type) {
 stopAnimation();
 isAnimating = true;
 
 switch(type) {
 case 'single':
 animateSingleBox();
 break;
 case 'multiple':
 animateMultipleBoxes();
 break;
 case 'tunnel':
 animateTunnel();
 break;
 }
}

function stopAnimation() {
 isAnimating = false;
 if (animationId) {
 cancelAnimationFrame(animationId);
 animationId = null;
 }
}

// Initialize
createWireframeBox(0);

// Handle window resize
window.addEventListener('resize', () =&gt; {
 if (!isAnimating) {
 createWireframeBox(0);
 }
});
&lt;/script&gt;
&lt;h2 id="technical-features"&gt;Technical Features&lt;/h2&gt;
&lt;h3 id="3d-mathematics"&gt;3D Mathematics&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Matrix transformations&lt;/strong&gt;: Full 4x4 matrix operations for 3D transformations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Perspective projection&lt;/strong&gt;: Realistic 3D-to-2D conversion with depth&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rotation matrices&lt;/strong&gt;: Separate X, Y, Z rotation calculations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vertex transformation&lt;/strong&gt;: Homogeneous coordinate system&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="wireframe-rendering"&gt;Wireframe Rendering&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cube definition&lt;/strong&gt;: 8 vertices, 12 edges in normalized space&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Edge rendering&lt;/strong&gt;: Dynamic line drawing with SVG&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vertex highlighting&lt;/strong&gt;: Color-coded corner points&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Depth sorting&lt;/strong&gt;: Simple back-face culling&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="animation-types"&gt;Animation Types&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Single Box&lt;/strong&gt;: Classic rotating wireframe cube&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multiple Boxes&lt;/strong&gt;: Several cubes with different scales and positions&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tunnel Effect&lt;/strong&gt;: Infinite tunnel of rotating wireframes&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="coordinate-system"&gt;Coordinate System&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 3D cube vertices in normalized coordinates (-1 to 1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;cubeVertices&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; [
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; [&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;], [ &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;], [ &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;], [&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;], &lt;span style="color:#75715e"&gt;// Front
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; [&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;], [ &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;], [ &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;], [&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;] &lt;span style="color:#75715e"&gt;// Back
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Transform to screen space
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;transformPoint&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;z&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;w&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;12&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;13&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;14&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;z&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;15&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;z&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;3&lt;/span&gt;]) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;w&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;x&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;5&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;y&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;6&lt;/span&gt;] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;z&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;matrix&lt;/span&gt;[&lt;span style="color:#ae81ff"&gt;7&lt;/span&gt;]) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;w&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="performance-optimizations"&gt;Performance Optimizations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Efficient matrix math&lt;/strong&gt;: Minimal allocations in animation loop&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SVG reuse&lt;/strong&gt;: Complete regeneration for smooth animation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Culling&lt;/strong&gt;: Skip rendering of vertices/edges behind camera&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color cycling&lt;/strong&gt;: HSL color space for smooth transitions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This wireframe system demonstrates how to build a complete 3D rendering pipeline using just SVG and JavaScript, with normalized coordinates providing a clean mathematical foundation!&lt;/p&gt;</description></item></channel></rss>