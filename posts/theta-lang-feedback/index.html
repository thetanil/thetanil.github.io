<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Theta-lang: Developer Feedback | Theta Nil's Site</title><link rel=stylesheet href=/css/main.min.d194f80c5cee2492dfb71945947fce036c8af59d50e34e16ab84b6e48dc7406a.css integrity="sha256-0ZT4DFzuJJLftxlFlH/OA2yK9Z1Q404Wq4S25I3HQGo=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>function getMermaidTheme(){return window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"default"}function initializeMermaid(){mermaid.initialize({startOnLoad:!1,theme:getMermaidTheme(),securityLevel:"loose",fontFamily:"inherit",themeVariables:{primaryColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#66b3ff":"#00e",primaryTextColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#e8e8e8":"#222",primaryBorderColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#222",lineColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#222",sectionBkgColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#2a2a2a":"#f9f9f9",altSectionBkgColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#1a1a1a":"#fff",gridColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#e0e0e0",tertiaryColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#3a3a3a":"#f0f0f0"}})}function processMermaidBlocks(){const e=document.querySelectorAll("code.language-mermaid");e.forEach((e,t)=>{const n=document.createElement("div");n.className="mermaid",n.id="mermaid-"+t,n.textContent=e.textContent;const s=e.parentElement;s.parentElement.replaceChild(n,s)}),e.length>0&&mermaid.init()}if(document.addEventListener("DOMContentLoaded",function(){initializeMermaid(),processMermaidBlocks()}),window.matchMedia){const e=window.matchMedia("(prefers-color-scheme: dark)");e.addEventListener("change",function(){initializeMermaid();const t=document.querySelectorAll(".mermaid");t.forEach((e,t)=>{e.id="mermaid-rerender-"+t,e.removeAttribute("data-processed")}),t.length>0&&mermaid.init()})}</script></head><body><header><div class=site-header><h1 class=site-title>Theta Nil's Site</h1><nav class=site-nav><nav><ul><li><a href=/>Home</a></li><li><a aria-current=true class=ancestor href=/posts/>Posts</a></li><li><a href=/tags/>Tags</a></li></ul></nav></nav></div></header><main><div class=site-content><h1>Theta-lang: Developer Feedback</h1><time datetime=2025-11-25T00:00:00+00:00>November 25, 2025</time><h2 id=questions-for-design-validation-and-implementation-guidance>Questions for Design Validation and Implementation Guidance</h2><p>As the developer tasked with implementing the Theta VM, I need clarification on several aspects of the design to ensure correct implementation and avoid costly refactoring. These questions are organized by architectural concern.</p><hr><h2 id=1-flatbuffer-schema-design-and-evolution>1. FlatBuffer Schema Design and Evolution</h2><h3 id=11-schema-versioning-strategy>1.1 Schema Versioning Strategy</h3><p><strong>Q:</strong> How should schema evolution be handled when the VM state structure changes between releases?</p><ul><li>Should we use FlatBuffers&rsquo; built-in schema evolution (adding optional fields)?</li><li>Do we need explicit version tags in each root table?</li><li>How should we handle incompatible changes (e.g., removing required fields)?</li><li>Should old VM states be forward-convertible, or is it acceptable to reject incompatible versions?</li></ul><h3 id=12-nested-vs-flat-table-design>1.2 Nested vs. Flat Table Design</h3><p><strong>Q:</strong> How deeply should we nest FlatBuffer tables?</p><ul><li>Example: Should <code>ExecutionState</code> contain nested <code>CallFrame</code> tables, or should it reference them by ID in a separate table?</li><li>Deep nesting simplifies access but complicates mutation (requires rebuilding entire tree)</li><li>Flat design with references adds indirection but allows partial updates</li><li>What is the preferred trade-off for this VM?</li></ul><h3 id=13-string-handling>1.3 String Handling</h3><p><strong>Q:</strong> How should strings be represented and managed?</p><ul><li>Should strings be inline in value tables, or stored in a separate string pool with offsets?</li><li>How do we handle string lifecycle (when can strings be freed)?</li><li>Should we support string interning for deduplication?</li><li>What encoding should be enforced (UTF-8, ASCII, raw bytes)?</li></ul><h3 id=14-schema-organization>1.4 Schema Organization</h3><p><strong>Q:</strong> Should all schemas be in a single <code>.fbs</code> file or split across multiple files?</p><ul><li>Single file: easier to maintain consistency, harder to navigate</li><li>Multiple files: better organization, requires careful dependency management</li><li>What granularity is preferred?</li></ul><hr><h2 id=2-memory-management-and-buffer-lifecycle>2. Memory Management and Buffer Lifecycle</h2><h3 id=21-buffer-ownership-model>2.1 Buffer Ownership Model</h3><p><strong>Q:</strong> Who owns FlatBuffer regions, and when are they freed?</p><ul><li>Does the VM own all buffers and free them on shutdown?</li><li>Can the host retain references after VM shutdown?</li><li>Should we use reference counting, or is manual lifetime management expected?</li><li>What happens if the host holds a pointer to a buffer that the VM wants to replace?</li></ul><h3 id=22-buffer-replacement-strategy>2.2 Buffer Replacement Strategy</h3><p><strong>Q:</strong> When VM state changes (e.g., new register values), how do we handle buffer replacement?</p><ul><li>Do we rebuild the entire <code>ExecutionState</code> buffer on every instruction?</li><li>Should we use a &ldquo;dirty region&rdquo; approach where only modified portions are rebuilt?</li><li>Can we keep multiple generations of buffers alive simultaneously?</li><li>How do we garbage collect old buffers?</li></ul><h3 id=23-allocation-strategy>2.3 Allocation Strategy</h3><p><strong>DECIDED:</strong> Arena allocation with bump-pointer allocators.</p><ul><li>Each computation phase gets its own arena (module, execution, dataflow results)</li><li><strong>Open question:</strong> Should we support host-provided arena implementations (callback-based)?</li><li><strong>Open question:</strong> What is the expected buffer size distribution for arena sizing (small, large, mixed)?</li></ul><h3 id=24-memory-limits>2.4 Memory Limits</h3><p><strong>Q:</strong> How should memory consumption be bounded?</p><ul><li>Should there be a global memory limit for all VM buffers?</li><li>Should individual buffers be size-limited?</li><li>What happens when memory limits are exceeded (error, eviction, spilling)?</li></ul><hr><h2 id=3-procedural-execution-model>3. Procedural Execution Model</h2><h3 id=31-register-file-size-and-type>3.1 Register File Size and Type</h3><p><strong>DECIDED:</strong> 256 typed registers (r0-r255) with unified register file.</p><ul><li>r0: constant zero (read-only)</li><li>r1: function return value</li><li>r2-r15: argument passing registers</li><li>r16-r255: general purpose</li><li>Types: i8, i16, i32, i64, f32, f64, bool, ptr, string, table_ref, node_ref</li><li><strong>Open question:</strong> Should we support register spilling for functions that need more than 256 registers?</li></ul><h3 id=32-calling-convention>3.2 Calling Convention</h3><p><strong>Q:</strong> How should function calls and returns be implemented?</p><ul><li>How are arguments passed (registers, stack, both)?</li><li>How are return values communicated?</li><li>Should we support multiple return values?</li><li>How is the caller&rsquo;s context saved (which registers are callee-saved)?</li></ul><h3 id=33-control-flow-implementation>3.3 Control Flow Implementation</h3><p><strong>Q:</strong> How should branching and loops be encoded?</p><ul><li>Should branch targets be absolute offsets, relative offsets, or labels resolved at load time?</li><li>How do we handle backward branches (loop detection)?</li><li>Should we support computed jumps (switch/case optimization)?</li></ul><h3 id=34-instruction-encoding-density>3.4 Instruction Encoding Density</h3><p><strong>Q:</strong> How compact should instructions be?</p><ul><li>Should we optimize for space (variable-length encoding) or speed (fixed-width instructions)?</li><li>Should operands be inline or referenced?</li><li>What is the expected code size for typical programs (hundreds of instructions, thousands, millions)?</li></ul><h3 id=35-error-handling-model>3.5 Error Handling Model</h3><p><strong>Q:</strong> How should runtime errors be communicated?</p><ul><li>Should the VM trap and halt on errors, or support structured exception handling?</li><li>Can procedural code catch and handle errors from dataflow operations?</li><li>Should we support unwinding the call stack on errors?</li><li>How are error messages and diagnostics communicated to the host?</li></ul><hr><h2 id=4-dataflow-execution-model>4. Dataflow Execution Model</h2><h3 id=41-execution-strategy-eager-vs-lazy>4.1 Execution Strategy (Eager vs. Lazy)</h3><p><strong>DECIDED:</strong> Lazy pull-based evaluation with explicit materialization.</p><ul><li>Dataflow nodes are constructed without executing (build DAG only)</li><li>Execution occurs when host/procedural code calls <code>materialize(node)</code></li><li>Pull model: each operator implements iterator interface (next(), reset())</li><li><strong>Open question:</strong> Should we support partial materialization (first N rows)?</li><li><strong>Open question:</strong> Should we cache materialized results for repeated access?</li></ul><h3 id=42-operator-fusion>4.2 Operator Fusion</h3><p><strong>Q:</strong> Should the dataflow engine perform operator fusion?</p><ul><li>Example: SCAN â†’ FILTER â†’ PROJECT could be fused into a single pass</li><li>If yes, when does fusion occur (compile-time, runtime, never)?</li><li>How does fusion interact with the FlatBuffer representation (fused nodes vs. separate nodes)?</li></ul><h3 id=43-dataflow-node-mutability>4.3 Dataflow Node Mutability</h3><p><strong>Q:</strong> Can dataflow nodes be modified after creation?</p><ul><li>Can a node&rsquo;s parameters be changed (e.g., update a filter predicate)?</li><li>If yes, does this create a new node or mutate in place?</li><li>How does this affect memoization or caching?</li></ul><h3 id=44-table-representation>4.4 Table Representation</h3><p><strong>DECIDED:</strong> Columnar storage with typed columns.</p><ul><li>Each column is a separate typed array (i8[], i16[], i32[], i64[], f32[], f64[], bool[], string)</li><li>Null handling: bit-packed null bitmap (1 bit per row, 0=null, 1=valid)</li><li>String columns: offset array [u32] + concatenated UTF-8 data buffer</li><li><strong>Open question:</strong> Should we support compressed columns (RLE, dictionary encoding)?</li><li><strong>Open question:</strong> Should we support nested columns (arrays, structs)?</li></ul><h3 id=45-intermediate-materialization>4.5 Intermediate Materialization</h3><p><strong>Q:</strong> When should intermediate dataflow results be materialized to FlatBuffers?</p><ul><li>After every operator (safe but slow)?</li><li>Only when requested by the host or procedural code (lazy but complex)?</li><li>Should the VM automatically decide based on memory pressure or access patterns?</li></ul><h3 id=46-streaming-vs-batch-processing>4.6 Streaming vs. Batch Processing</h3><p><strong>Q:</strong> Should dataflow operators process entire tables at once or support streaming?</p><ul><li>Batch: simpler to implement, requires full table materialization</li><li>Streaming: memory-efficient, more complex state management</li><li>Should we support both modes?</li></ul><hr><h2 id=5-procedural-dataflow-integration>5. Procedural-Dataflow Integration</h2><h3 id=51-value-type-system>5.1 Value Type System</h3><p><strong>Q:</strong> How do procedural values and dataflow results interoperate?</p><ul><li>Can a procedural register hold a reference to a table?</li><li>Can a table cell contain a reference to a procedural value or dataflow node?</li><li>How are types checked at the boundary?</li></ul><h3 id=52-dataflow-invocation>5.2 Dataflow Invocation</h3><p><strong>Q:</strong> How does procedural code trigger dataflow execution?</p><ul><li>Are there special instructions (EXECUTE_DATAFLOW_NODE)?</li><li>Can procedural code iterate over table rows?</li><li>How are dataflow errors propagated to procedural code?</li></ul><h3 id=53-procedural-functions-in-dataflow>5.3 Procedural Functions in Dataflow</h3><p><strong>Q:</strong> Can user-defined procedural functions be used in dataflow operators?</p><ul><li>Example: MAP operator that calls a procedural function for each row</li><li>If yes, how is the function called (direct C function pointer, bytecode interpreter)?</li><li>How are procedural function signatures validated for dataflow use?</li></ul><hr><h2 id=6-host-integration-and-api-design>6. Host Integration and API Design</h2><h3 id=61-api-surface>6.1 API Surface</h3><p><strong>Q:</strong> What level of abstraction should the host API provide?</p><ul><li>Low-level: direct access to FlatBuffer accessors (fast, unsafe)</li><li>High-level: wrapper functions that abstract FlatBuffers (safe, slower)</li><li>Should we provide both?</li></ul><h3 id=62-thread-safety>6.2 Thread Safety</h3><p><strong>Q:</strong> Is the VM thread-safe?</p><ul><li>Can multiple threads execute the same VM instance concurrently?</li><li>Can multiple threads access different VM instances?</li><li>Should the VM provide its own locking, or is synchronization the host&rsquo;s responsibility?</li></ul><h3 id=63-resource-cleanup>6.3 Resource Cleanup</h3><p><strong>Q:</strong> What is the cleanup contract between VM and host?</p><ul><li>Should the VM automatically free all resources on <code>vm_destroy()</code>?</li><li>Can the host retain buffer references after VM destruction?</li><li>Should we support explicit buffer pinning/unpinning?</li></ul><h3 id=64-error-reporting-to-host>6.4 Error Reporting to Host</h3><p><strong>Q:</strong> How should errors be communicated to the host?</p><ul><li>Error codes only (lightweight, requires lookup)?</li><li>Structured error objects in FlatBuffers (consistent, but complex)?</li><li>String error messages (human-readable, but allocation required)?</li></ul><h3 id=65-callback-mechanisms>6.5 Callback Mechanisms</h3><p><strong>Q:</strong> Should the VM support host callbacks?</p><ul><li>Can the VM call back into host code (e.g., for I/O, external functions)?</li><li>If yes, how are callbacks registered and invoked?</li><li>How do we ensure callbacks don&rsquo;t violate FlatBuffer immutability?</li></ul><hr><h2 id=7-type-system-and-type-safety>7. Type System and Type Safety</h2><h3 id=71-static-vs-dynamic-typing>7.1 Static vs. Dynamic Typing</h3><p><strong>DECIDED:</strong> Statically typed with type checking at module load time.</p><ul><li>All variables, function parameters, and return values have explicit types</li><li>Type checking occurs during module loading (before execution)</li><li>No implicit type conversions (explicit casts required)</li><li><strong>Open question:</strong> Should we support type inference for local variables?</li><li><strong>Open question:</strong> Should we allow generic/polymorphic functions?</li></ul><h3 id=72-type-inference>7.2 Type Inference</h3><p><strong>Q:</strong> Should the system infer types, or must they be explicit?</p><ul><li>For procedural code: do variables have declared types?</li><li>For dataflow operations: are output schemas inferred from inputs?</li><li>How are type errors reported?</li></ul><h3 id=73-null-handling>7.3 Null Handling</h3><p><strong>Q:</strong> How are null values represented and handled?</p><ul><li>Should we use nullable types throughout, or reserve special sentinel values?</li><li>How do arithmetic operations handle null (propagate, error, coerce)?</li><li>Do we support three-valued logic (true/false/null) for predicates?</li></ul><hr><h2 id=8-performance-and-optimization>8. Performance and Optimization</h2><h3 id=81-hot-path-identification>8.1 Hot Path Identification</h3><p><strong>Q:</strong> What are the expected performance bottlenecks?</p><ul><li>Instruction dispatch in procedural interpreter?</li><li>FlatBuffer accessor overhead?</li><li>Dataflow operator execution?</li><li>Memory allocation?</li><li>Where should we focus optimization effort?</li></ul><h3 id=82-simd-vectorization>8.2 SIMD Vectorization</h3><p><strong>Q:</strong> Should dataflow operators use SIMD intrinsics?</p><ul><li>If yes, which SIMD instruction sets (SSE, AVX, NEON, SVE)?</li><li>Should we have portable fallback implementations?</li><li>How much performance improvement is expected?</li></ul><h3 id=83-caching-and-memoization>8.3 Caching and Memoization</h3><p><strong>Q:</strong> Should the VM cache intermediate results?</p><ul><li>Should dataflow nodes memoize their outputs?</li><li>Should we cache decoded instructions?</li><li>How is cache invalidation handled?</li></ul><h3 id=84-profiling-hooks>8.4 Profiling Hooks</h3><p><strong>Q:</strong> Should the VM provide built-in profiling?</p><ul><li>Instruction counts per opcode?</li><li>Operator execution times?</li><li>Memory allocation tracking?</li><li>Should profiling be always-on or opt-in?</li></ul><hr><h2 id=9-debugging-and-observability>9. Debugging and Observability</h2><h3 id=91-debugger-support>9.1 Debugger Support</h3><p><strong>Q:</strong> What debugging capabilities should be built in?</p><ul><li>Breakpoints (at instruction, at function, at dataflow node)?</li><li>Single-stepping?</li><li>Watchpoints (register or memory changes)?</li><li>How is debugger state represented (also in FlatBuffers)?</li></ul><h3 id=92-logging-and-tracing>9.2 Logging and Tracing</h3><p><strong>Q:</strong> Should the VM have internal logging?</p><ul><li>If yes, what logging levels (error, warn, info, debug, trace)?</li><li>Should logs be directed to stdout, a file, or a host callback?</li><li>Should execution traces be recordable for replay?</li></ul><h3 id=93-introspection-depth>9.3 Introspection Depth</h3><p><strong>Q:</strong> How much VM internals should be exposed?</p><ul><li>Should the host see every instruction execution?</li><li>Should the host be able to inspect in-progress dataflow nodes?</li><li>What is the expected overhead of introspection?</li></ul><hr><h2 id=10-standard-library-and-io>10. Standard Library and I/O</h2><h3 id=101-io-model>10.1 I/O Model</h3><p><strong>Q:</strong> How should I/O be performed?</p><ul><li>Should the VM directly read files, or should the host provide data?</li><li>Should we support streaming file reads, or only in-memory buffers?</li><li>What file formats are essential (CSV, JSON, Parquet, custom)?</li></ul><h3 id=102-built-in-function-implementation>10.2 Built-in Function Implementation</h3><p><strong>Q:</strong> Should built-in functions be implemented in C or in VM bytecode?</p><ul><li>C: faster, but not introspectable</li><li>Bytecode: slower, but uniform representation</li><li>Hybrid: performance-critical in C, others in bytecode?</li></ul><h3 id=103-extension-mechanism>10.3 Extension Mechanism</h3><p><strong>Q:</strong> Can users add custom functions without modifying VM code?</p><ul><li>Should we support loading external C functions (shared libraries)?</li><li>Should there be a plugin API?</li><li>How are external functions registered and called?</li></ul><hr><h2 id=11-security-and-sandboxing>11. Security and Sandboxing</h2><h3 id=111-untrusted-code-execution>11.1 Untrusted Code Execution</h3><p><strong>Q:</strong> Is the VM designed to run untrusted bytecode?</p><ul><li>If yes, what security guarantees are provided?</li><li>Should we validate bytecode before execution (type safety, bounds checks)?</li><li>How do we prevent resource exhaustion attacks (infinite loops, memory bombs)?</li></ul><h3 id=112-host-access-restrictions>11.2 Host Access Restrictions</h3><p><strong>Q:</strong> Can VM code access host resources arbitrarily?</p><ul><li>Should there be a capability-based security model?</li><li>Should I/O operations require explicit host permission?</li><li>How are security violations detected and handled?</li></ul><hr><h2 id=12-testing-and-validation>12. Testing and Validation</h2><h3 id=121-test-coverage-goals>12.1 Test Coverage Goals</h3><p><strong>Q:</strong> What test coverage is required?</p><ul><li>Should we aim for 100% line coverage?</li><li>What are critical paths that must be tested?</li><li>Should we have integration tests, unit tests, or both?</li></ul><h3 id=122-fuzzing-strategy>12.2 Fuzzing Strategy</h3><p><strong>Q:</strong> Should we fuzz the VM?</p><ul><li>Fuzz bytecode loading?</li><li>Fuzz dataflow graph construction?</li><li>Fuzz FlatBuffer inputs?</li><li>What fuzzing tools should we use (AFL, libFuzzer, custom)?</li></ul><h3 id=123-conformance-testing>12.3 Conformance Testing</h3><p><strong>Q:</strong> How do we verify correctness?</p><ul><li>Should we have a reference implementation?</li><li>Should we compare against Lua or DuckDB for equivalent operations?</li><li>How do we test determinism across platforms?</li></ul><hr><h2 id=13-deployment-and-distribution>13. Deployment and Distribution</h2><h3 id=131-build-artifacts>13.1 Build Artifacts</h3><p><strong>Q:</strong> What should the build produce?</p><ul><li>Static library, shared library, or both?</li><li>Should we distribute source or binaries?</li><li>What platforms should we support (Linux, macOS, Windows, embedded)?</li></ul><h3 id=132-dependencies>13.2 Dependencies</h3><p><strong>Q:</strong> How should FlatBuffers be included?</p><ul><li>As a git submodule?</li><li>As a system dependency (pkg-config)?</li><li>Vendored directly into the repository?</li></ul><h3 id=133-versioning-scheme>13.3 Versioning Scheme</h3><p><strong>Q:</strong> How should versions be numbered?</p><ul><li>Semantic versioning (major.minor.patch)?</li><li>What constitutes a breaking change (schema change, API change, behavior change)?</li><li>How are deprecations communicated?</li></ul><hr><h2 id=14-specific-design-ambiguities>14. Specific Design Ambiguities</h2><h3 id=141-dataflow-graph-topology>14.1 Dataflow Graph Topology</h3><p><strong>Q:</strong> Are dataflow graphs always DAGs, or can they contain cycles?</p><ul><li>If cycles are allowed, how do we prevent infinite recursion?</li><li>Should we support iterative dataflow (fixed-point computation)?</li></ul><h3 id=142-procedural-language-syntax>14.2 Procedural Language Syntax</h3><p><strong>DECIDED:</strong> Statically typed, C-like procedural language.</p><ul><li>Imperative control flow: if/else, while, for, break, continue, return</li><li>First-class functions with typed signatures</li><li>No classes/OOP, no garbage collection, no implicit conversions</li><li><strong>Open question:</strong> Should we provide a parser/compiler in Phase 1, or start with direct bytecode generation?</li><li><strong>Open question:</strong> What is the exact syntax for function definitions, type annotations, and dataflow integration?</li></ul><h3 id=143-dataflow-operator-semantics>14.3 Dataflow Operator Semantics</h3><p><strong>Q:</strong> What are the precise semantics of each operator?</p><ul><li>JOIN: inner, left, right, full outer - which are supported?</li><li>AGGREGATE: how are ties broken in MIN/MAX?</li><li>SORT: stable or unstable sort?</li><li>Should we document semantics formally (operational semantics, denotational)?</li></ul><h3 id=144-endianness-handling>14.4 Endianness Handling</h3><p><strong>Q:</strong> How do we handle mixed-endianness environments?</p><ul><li>Does FlatBuffers already solve this (yes for schema-defined fields)?</li><li>What about raw byte arrays in Value unions?</li><li>Should we enforce a canonical byte order?</li></ul><hr><h2 id=15-project-specific-questions>15. Project-Specific Questions</h2><h3 id=151-name-and-branding>15.1 Name and Branding</h3><p><strong>Q:</strong> What is the official name of this VM?</p><ul><li>&ldquo;Theta VM&rdquo; is used in the plan - is this confirmed?</li><li>Should schemas use &ldquo;theta&rdquo; as a namespace prefix?</li></ul><h3 id=152-license>15.2 License</h3><p><strong>Q:</strong> What license should the project use?</p><ul><li>Permissive (MIT, Apache 2.0)?</li><li>Copyleft (GPL, LGPL)?</li><li>Does the license affect FlatBuffers integration?</li></ul><h3 id=153-target-use-cases>15.3 Target Use Cases</h3><p><strong>Q:</strong> What are the primary expected use cases?</p><ul><li>Embedded analytics in applications?</li><li>Scripting layer for data processing?</li><li>Research prototype?</li><li>Understanding target use cases will guide design trade-offs.</li></ul><hr><h2 id=priority-questions-summary>Priority Questions Summary</h2><h3 id=-decided-core-design-decisions>âœ… DECIDED (Core Design Decisions)</h3><p>The following critical questions have been answered and are documented in design-decisions.md:</p><ol><li>âœ… <strong>Memory ownership model</strong> - Arena allocation with bump-pointer allocators</li><li>âœ… <strong>Register file architecture</strong> - 256 typed registers (r0-r255)</li><li>âœ… <strong>Table storage layout</strong> - Columnar storage with typed columns</li><li>âœ… <strong>Eager vs. lazy dataflow</strong> - Lazy pull-based evaluation with explicit materialization</li><li>âœ… <strong>Static vs. dynamic typing</strong> - Statically typed with load-time type checking</li><li>âœ… <strong>Procedural language syntax</strong> - C-like, statically typed, imperative</li></ol><h3 id=-high-priority-blockers-for-implementation>ðŸŸ¡ HIGH PRIORITY (Blockers for Implementation)</h3><p>These questions should be answered before beginning Phase 1 implementation:</p><ol><li><strong>Schema organization</strong> (Section 1.4) - Single file vs. multiple files for schemas</li><li><strong>String handling</strong> (Section 1.3) - Interning, lifecycle, encoding enforcement</li><li><strong>Buffer replacement strategy</strong> (Section 2.2) - Frequency and granularity of rebuilds</li><li><strong>Calling convention</strong> (Section 3.2) - Argument passing, return values, register saving</li><li><strong>Control flow encoding</strong> (Section 3.3) - Branch target format (absolute, relative, labels)</li><li><strong>Instruction encoding density</strong> (Section 3.4) - Fixed-width vs. variable-length</li><li><strong>Streaming vs. batch</strong> (Section 4.6) - Row-at-a-time vs. batch processing</li><li><strong>Thread safety</strong> (Section 6.2) - Concurrent access model</li></ol><h3 id=-medium-priority-can-be-deferred-to-later-phases>ðŸ”µ MEDIUM PRIORITY (Can be deferred to later phases)</h3><p>These can be decided during implementation:</p><ol><li>Operator fusion strategy (Section 4.2)</li><li>Error handling model (Section 3.5)</li><li>Host API abstraction level (Section 6.1)</li><li>SIMD vectorization strategy (Section 8.2)</li><li>Operator semantics details (Section 14.3)</li></ol><h3 id=-low-priority-optimizationproduction-concerns>ðŸŸ¢ LOW PRIORITY (Optimization/Production concerns)</h3><p>These can be addressed in Phases 8-10:</p><ol><li>Caching and memoization (Section 8.3)</li><li>Profiling hooks (Section 8.4)</li><li>Security sandboxing (Section 11)</li><li>Compression support (Section 4.4 open questions)</li></ol><div><div>Tags:</div><ul><li><a href=/tags/theta-lang/>Theta-Lang</a></li><li><a href=/tags/vm/>Vm</a></li><li><a href=/tags/design/>Design</a></li><li><a href=/tags/flatbuffers/>Flatbuffers</a></li><li><a href=/tags/dataflow/>Dataflow</a></li></ul></div></div></main><footer><p>Copyright 2025. All rights reserved.</p></footer></body></html>