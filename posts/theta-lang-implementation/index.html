<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Theta-lang: Implementation Plan: FlatBuffer-Backed Procedural Dataflow VM | Theta Nil's Site</title><link rel=stylesheet href=/css/main.min.c7a5c1c6627bdd92510df0d2272d0f86694f49366048d0ee3065e20d315759b3.css integrity="sha256-x6XBxmJ73ZJRDfDSJy0PhmlPSTZgSNDuMGXiDTFXWbM=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>function getMermaidTheme(){return window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"default"}function initializeMermaid(){mermaid.initialize({startOnLoad:!1,theme:getMermaidTheme(),securityLevel:"loose",fontFamily:"inherit",themeVariables:{primaryColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#66b3ff":"#00e",primaryTextColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#e8e8e8":"#222",primaryBorderColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#222",lineColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#222",sectionBkgColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#2a2a2a":"#f9f9f9",altSectionBkgColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#1a1a1a":"#fff",gridColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#e0e0e0",tertiaryColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#3a3a3a":"#f0f0f0"}})}function processMermaidBlocks(){const e=document.querySelectorAll("code.language-mermaid");e.forEach((e,t)=>{const n=document.createElement("div");n.className="mermaid",n.id="mermaid-"+t,n.textContent=e.textContent;const s=e.parentElement;s.parentElement.replaceChild(n,s)}),e.length>0&&mermaid.init()}if(document.addEventListener("DOMContentLoaded",function(){initializeMermaid(),processMermaidBlocks()}),window.matchMedia){const e=window.matchMedia("(prefers-color-scheme: dark)");e.addEventListener("change",function(){initializeMermaid();const t=document.querySelectorAll(".mermaid");t.forEach((e,t)=>{e.id="mermaid-rerender-"+t,e.removeAttribute("data-processed")}),t.length>0&&mermaid.init()})}</script></head><body><header><h1>Theta Nil's Site</h1><nav><ul><li><a href=/>Home</a></li><li><a aria-current=true class=ancestor href=/posts/>Posts</a></li><li><a href=/tags/>Tags</a></li></ul></nav></header><main><h1>Theta-lang: Implementation Plan: FlatBuffer-Backed Procedural Dataflow VM</h1><time datetime=2025-11-25T00:00:00+00:00>November 25, 2025</time><h2 id=project-theta-virtual-machine>Project: Theta Virtual Machine</h2><p><strong>Target Language:</strong> C11
<strong>Architecture:</strong> Three-layer VM with procedural execution, dataflow engine, and FlatBuffer-backed shared memory</p><p><strong>Core Design Decisions:</strong></p><ul><li><strong>Memory Model:</strong> Arena allocation with bump-pointer allocators</li><li><strong>Register Architecture:</strong> 256 typed registers (r0-r255)</li><li><strong>Language:</strong> Statically typed, C-like procedural language</li><li><strong>Storage:</strong> Columnar table layout with typed columns</li><li><strong>Execution:</strong> Pull-based lazy evaluation with DAG interpreter</li></ul><hr><h2 id=phase-1-foundation---flatbuffers-schema-definition>Phase 1: Foundation - FlatBuffers Schema Definition</h2><h3 id=11-core-type-system-schema>1.1 Core Type System Schema</h3><ul><li>Define primitive type enumeration (i8, i16, i32, i64, f32, f64, bool, string)</li><li>Define reference types (ptr, table_ref, node_ref)</li><li>Create type descriptor tables with nullability, stride, and alignment metadata</li><li>Design schema versioning strategy</li></ul><h3 id=12-memory-layout-schema-arena-based>1.2 Memory Layout Schema (Arena-Based)</h3><ul><li>Define Arena table (base pointer, current offset, capacity, generation ID)</li><li>Define ArenaPool table for managing multiple arena generations</li><li>Create buffer metadata (arena reference, offset, size)</li><li>Design arena lifecycle tracking (creation, active, retired, freed)</li></ul><h3 id=13-value-representation-schema>1.3 Value Representation Schema</h3><ul><li>Define Value union type (scalar, table reference, dataflow node reference)</li><li>Create ScalarValue table (type tag, raw bytes)</li><li>Design TableValue table (schema reference, row count, column references)</li><li>Define DataflowNodeReference (node ID, output port)</li></ul><h3 id=14-schema-evolution-strategy>1.4 Schema Evolution Strategy</h3><ul><li>Implement schema version numbering</li><li>Design backward compatibility layer for schema changes</li><li>Create validation utilities for schema conformance</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>schemas/types.fbs</code> - Type system definitions</li><li><code>schemas/memory.fbs</code> - Memory management structures</li><li><code>schemas/values.fbs</code> - Runtime value representations</li><li><code>schemas/versioning.fbs</code> - Schema evolution support</li></ul><hr><h2 id=phase-2-procedural-layer-foundation>Phase 2: Procedural Layer Foundation</h2><h3 id=21-instruction-set-architecture-typed-instructions>2.1 Instruction Set Architecture (Typed Instructions)</h3><ul><li>Define typed instruction enumeration (LOAD_I32, STORE_F64, ADD_I64, etc.)</li><li>Create Instruction table (opcode, typed operands)</li><li>Design register addressing (r0-r255 with type tags)</li><li>Define control flow instructions (BR, BR_IF, CALL, RET)</li><li>Implement type validation for instruction operands</li></ul><h3 id=22-program-representation>2.2 Program Representation</h3><ul><li>Define Function table (name, typed parameters, typed locals, typed return, instruction sequence)</li><li>Create Module table (function list with signatures, typed constant pool, import/export tables)</li><li>Design ConstantPool table (typed constants: scalar, string, table_ref)</li><li>Implement function signature validation (type checking at load time)</li></ul><h3 id=23-execution-state-schema-typed-register-file>2.3 Execution State Schema (Typed Register File)</h3><ul><li>Define TypedRegister table (register number, type tag, value union)</li><li>Create RegisterFile table (256 registers: r0-r255)<ul><li>r0: constant zero (read-only)</li><li>r1: function return value</li><li>r2-r15: argument passing</li><li>r16-r255: general purpose</li></ul></li><li>Design CallFrame table (return address, base register, saved register snapshot)</li><li>Define CallStack table (array of call frames, frame pointer)</li><li>Create ExecutionState table (program counter, typed register file, call stack, current arena)</li></ul><h3 id=24-c11-interpreter-core>2.4 C11 Interpreter Core</h3><ul><li>Implement instruction decoder (FlatBuffer accessor → operation)</li><li>Create register file manipulator (load/store operations)</li><li>Build call stack manager (push/pop frames)</li><li>Implement control flow executor (branches, loops)</li><li>Design error handling model (trap codes, error propagation)</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>schemas/instructions.fbs</code> - Instruction set schema</li><li><code>schemas/program.fbs</code> - Program representation</li><li><code>schemas/execution.fbs</code> - Runtime execution state</li><li><code>src/interpreter/decoder.c</code> - Instruction decoder</li><li><code>src/interpreter/executor.c</code> - Execution engine</li><li><code>src/interpreter/callstack.c</code> - Call stack management</li></ul><hr><h2 id=phase-3-dataflow-layer-foundation>Phase 3: Dataflow Layer Foundation</h2><h3 id=31-operator-schema-definition>3.1 Operator Schema Definition</h3><ul><li>Define operator enumeration (SCAN, FILTER, PROJECT, MAP, REDUCE, JOIN, AGGREGATE, SORT)</li><li>Create Operator table (operator type, parameters, metadata)</li><li>Design operator parameter encoding (predicate expressions, projection lists, join conditions)</li></ul><h3 id=32-dataflow-graph-schema-dag>3.2 Dataflow Graph Schema (DAG)</h3><ul><li>Define DataflowNode table (node ID, operator, input node references, output schema)</li><li>Create DataflowGraph table (node list, topological ordering for validation)</li><li>Design node dependency tracking (enforce DAG constraint, detect cycles)</li><li>Implement graph validation (no cycles, valid input references)</li></ul><h3 id=33-table-schema-definition-columnar-layout>3.3 Table Schema Definition (Columnar Layout)</h3><ul><li>Define Column table:<ul><li>name: string</li><li>type: ColumnType (i8, i16, i32, i64, f32, f64, bool, string)</li><li>nullable: bool</li><li>null_bitmap: [u8] (bit-packed, 1 bit per row)</li><li>data: [u8] (typed data buffer or string offsets+data)</li></ul></li><li>Create Table table (schema, column array, row count)</li><li>Design StringColumn (offsets array + concatenated UTF-8 data)</li><li>Implement schema inference utilities</li></ul><h3 id=34-dataflow-executor-pull-based-iterator-model>3.4 Dataflow Executor (Pull-Based Iterator Model)</h3><ul><li>Define NodeIterator interface (next(), reset() operations)</li><li>Implement operator iterator dispatch (node type → iterator constructor)</li><li>Create SCAN iterator (read from columnar FlatBuffer table)</li><li>Implement FILTER iterator (pull from input, evaluate predicate, pass matching rows)</li><li>Build PROJECT iterator (pull from input, select/reorder columns)</li><li>Design MAP iterator (pull from input, apply transformation per row)</li><li>Implement materialize() function (pull all rows, build new FlatBuffer in arena)</li></ul><h3 id=35-expression-evaluation>3.5 Expression Evaluation</h3><ul><li>Define expression tree schema (binary ops, unary ops, literals, column references)</li><li>Implement expression evaluator (recursive descent on expression tree)</li><li>Create predicate evaluator for FILTER operations</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>schemas/operators.fbs</code> - Dataflow operator definitions</li><li><code>schemas/dataflow.fbs</code> - Dataflow graph structure</li><li><code>schemas/tables.fbs</code> - Table and column schemas</li><li><code>schemas/expressions.fbs</code> - Expression trees</li><li><code>src/dataflow/executor.c</code> - Operator executor</li><li><code>src/dataflow/operators/</code> - Individual operator implementations</li><li><code>src/dataflow/expressions.c</code> - Expression evaluator</li></ul><hr><h2 id=phase-4-integration-layer>Phase 4: Integration Layer</h2><h3 id=41-procedural-dataflow-bridge>4.1 Procedural-Dataflow Bridge</h3><ul><li>Design instruction set for dataflow operations (CREATE_NODE, EXECUTE_NODE, MATERIALIZE)</li><li>Implement dataflow node creation from procedural code</li><li>Create mechanism to pass dataflow results to registers</li><li>Build reference counting for dataflow node lifecycle</li></ul><h3 id=42-flatbuffer-builder-integration>4.2 FlatBuffer Builder Integration</h3><ul><li>Create wrapper for FlatBuffers builder API</li><li>Implement result materialization (dataflow output → new FlatBuffer)</li><li>Design buffer pool management (allocation, reuse, freeing)</li><li>Build buffer versioning layer (maintain multiple generations)</li></ul><h3 id=43-immutability-enforcement>4.3 Immutability Enforcement</h3><ul><li>Implement copy-on-write semantics for modified data</li><li>Design buffer snapshot mechanism</li><li>Create buffer lineage tracking (derivation chains)</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>src/integration/bridge.c</code> - Procedural-dataflow bridge</li><li><code>src/integration/builder.c</code> - FlatBuffer builder wrapper</li><li><code>src/integration/buffers.c</code> - Buffer pool manager</li><li><code>schemas/integration.fbs</code> - Integration layer schemas</li></ul><hr><h2 id=phase-5-host-interoperability>Phase 5: Host Interoperability</h2><h3 id=51-host-api-definition>5.1 Host API Definition</h3><ul><li>Define VM initialization API (<code>vm_create</code>, <code>vm_destroy</code>)</li><li>Create program loading API (<code>vm_load_module</code>, <code>vm_unload_module</code>)</li><li>Design execution API (<code>vm_execute_function</code>, <code>vm_step</code>, <code>vm_resume</code>)</li><li>Implement state inspection API (<code>vm_get_state</code>, <code>vm_get_register</code>, <code>vm_get_dataflow_graph</code>)</li><li>Build result extraction API (<code>vm_get_result_table</code>, <code>vm_materialize_node</code>)</li></ul><h3 id=52-zero-copy-access-guarantees>5.2 Zero-Copy Access Guarantees</h3><ul><li>Document buffer lifetime semantics</li><li>Implement buffer pinning mechanism (prevent premature freeing)</li><li>Create buffer accessor utilities for host languages</li><li>Design error propagation to host (error codes, structured error objects)</li></ul><h3 id=53-host-language-bindings>5.3 Host Language Bindings</h3><ul><li>Generate C header files from FlatBuffer schemas</li><li>Create Python binding layer (using FlatBuffers Python library)</li><li>Implement Rust binding layer (using FlatBuffers Rust library)</li><li>Design Go binding layer (using FlatBuffers Go library)</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>include/theta_vm.h</code> - Public C API</li><li><code>bindings/python/</code> - Python host bindings</li><li><code>bindings/rust/</code> - Rust host bindings</li><li><code>bindings/go/</code> - Go host bindings</li><li><code>docs/host_integration.md</code> - Integration guide</li></ul><hr><h2 id=phase-6-advanced-dataflow-operations>Phase 6: Advanced Dataflow Operations</h2><h3 id=61-join-operators>6.1 Join Operators</h3><ul><li>Implement hash join (build hash table, probe)</li><li>Create nested loop join (fallback for non-equi joins)</li><li>Design sort-merge join (for sorted inputs)</li></ul><h3 id=62-aggregation-operators>6.2 Aggregation Operators</h3><ul><li>Implement GROUP BY execution (hash-based grouping)</li><li>Create aggregate functions (SUM, COUNT, AVG, MIN, MAX)</li><li>Design streaming aggregation for memory efficiency</li></ul><h3 id=63-sort-operator>6.3 Sort Operator</h3><ul><li>Implement multi-column sort with collation</li><li>Create external sort for large datasets (spill to disk)</li></ul><h3 id=64-query-optimization-pre-execution>6.4 Query Optimization (Pre-Execution)</h3><ul><li>Implement predicate pushdown (move filters closer to scans)</li><li>Create projection pushdown (only read needed columns from source)</li><li>Design operator fusion (combine filter→project→map into single pass)</li><li>Implement common subexpression elimination (reuse shared DAG subtrees)</li><li>Note: Lazy pull-based evaluation is already implemented in Phase 3.4</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>src/dataflow/operators/join.c</code> - Join implementations</li><li><code>src/dataflow/operators/aggregate.c</code> - Aggregation operators</li><li><code>src/dataflow/operators/sort.c</code> - Sort operator</li><li><code>src/dataflow/lazy_executor.c</code> - Lazy evaluation engine</li><li><code>src/dataflow/optimizer.c</code> - Query optimization</li></ul><hr><h2 id=phase-7-safety-and-correctness>Phase 7: Safety and Correctness</h2><h3 id=71-memory-safety>7.1 Memory Safety</h3><ul><li>Implement bounds checking for all buffer accesses</li><li>Create assertion framework for invariant checking</li><li>Design buffer validity verification (detect corruption)</li><li>Build memory leak detection utilities</li></ul><h3 id=72-determinism-validation>7.2 Determinism Validation</h3><ul><li>Create reproducibility test suite (same input → same output)</li><li>Implement instruction execution tracing</li><li>Design regression testing framework</li></ul><h3 id=73-platform-portability>7.3 Platform Portability</h3><ul><li>Test on x86-64, ARM64, RISC-V architectures</li><li>Validate endianness handling</li><li>Test alignment requirement compliance</li><li>Verify float/double precision consistency</li></ul><h3 id=74-error-handling>7.4 Error Handling</h3><ul><li>Define error code enumeration (type errors, bounds errors, execution errors)</li><li>Create structured error reporting (error message, location, stack trace)</li><li>Implement graceful degradation (trap and unwind vs. abort)</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>src/safety/bounds_check.c</code> - Bounds checking utilities</li><li><code>src/safety/validator.c</code> - Buffer validation</li><li><code>tests/determinism/</code> - Determinism test suite</li><li><code>tests/portability/</code> - Cross-platform tests</li><li><code>src/errors/</code> - Error handling infrastructure</li></ul><hr><h2 id=phase-8-tooling-and-developer-experience>Phase 8: Tooling and Developer Experience</h2><h3 id=81-vm-introspection-tools>8.1 VM Introspection Tools</h3><ul><li>Build execution state dumper (print current VM state)</li><li>Create dataflow graph visualizer (DOT format export)</li><li>Implement instruction disassembler (bytecode → human-readable)</li><li>Design execution tracer (log each instruction)</li></ul><h3 id=82-debugging-support>8.2 Debugging Support</h3><ul><li>Implement breakpoint mechanism</li><li>Create single-step execution mode</li><li>Build register watch facility</li><li>Design dataflow node inspection utilities</li></ul><h3 id=83-performance-analysis>8.3 Performance Analysis</h3><ul><li>Create execution profiler (instruction counts, operator timings)</li><li>Implement memory usage analyzer</li><li>Build dataflow bottleneck detector</li></ul><h3 id=84-documentation>8.4 Documentation</h3><ul><li>Write architecture overview documentation</li><li>Create FlatBuffer schema documentation</li><li>Document instruction set reference</li><li>Write operator semantics guide</li><li>Create host integration tutorial</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>tools/vm_inspect</code> - State inspection tool</li><li><code>tools/df_visualizer</code> - Dataflow graph visualizer</li><li><code>tools/disassembler</code> - Bytecode disassembler</li><li><code>tools/profiler</code> - Performance profiler</li><li><code>docs/architecture.md</code> - Architecture documentation</li><li><code>docs/instruction_set.md</code> - ISA reference</li><li><code>docs/operators.md</code> - Dataflow operator reference</li></ul><hr><h2 id=phase-9-standard-library-and-built-ins>Phase 9: Standard Library and Built-ins</h2><h3 id=91-built-in-functions>9.1 Built-in Functions</h3><ul><li>Implement string manipulation functions</li><li>Create mathematical functions (sin, cos, sqrt, log, exp)</li><li>Design date/time manipulation functions</li><li>Build type conversion functions</li></ul><h3 id=92-io-operations>9.2 I/O Operations</h3><ul><li>Design file reading operators (CSV, JSON, Parquet)</li><li>Implement table serialization (export to formats)</li><li>Create streaming I/O for large datasets</li></ul><h3 id=93-standard-dataflow-patterns>9.3 Standard Dataflow Patterns</h3><ul><li>Create common query templates (group-aggregate, window functions)</li><li>Implement reusable transformation pipelines</li></ul><p><strong>Deliverables:</strong></p><ul><li><code>src/stdlib/</code> - Standard library implementations</li><li><code>src/io/</code> - I/O operation implementations</li><li><code>schemas/stdlib.fbs</code> - Standard library schemas</li><li><code>docs/stdlib.md</code> - Standard library reference</li></ul><hr><h2 id=phase-10-optimization-and-production-readiness>Phase 10: Optimization and Production Readiness</h2><h3 id=101-performance-optimization>10.1 Performance Optimization</h3><ul><li>Implement SIMD vectorization for hot paths (columnar operations, filters)</li><li>Create instruction dispatch optimization (computed goto, threaded code)</li><li>Optimize FlatBuffer access patterns (cache locality, prefetching)</li><li>Tune arena allocation parameters (arena size, growth strategy)</li></ul><h3 id=102-benchmarking>10.2 Benchmarking</h3><ul><li>Create benchmark suite (micro-benchmarks, end-to-end scenarios)</li><li>Compare against Lua (procedural execution speed)</li><li>Compare against DuckDB (dataflow operation speed)</li><li>Measure memory overhead</li></ul><h3 id=103-production-hardening>10.3 Production Hardening</h3><ul><li>Implement comprehensive error recovery</li><li>Create resource limitation enforcement (memory caps, execution timeouts)</li><li>Design security sandboxing (restrict host access)</li><li>Build graceful shutdown mechanism</li></ul><h3 id=104-release-engineering>10.4 Release Engineering</h3><ul><li>Create build system (CMake or Meson)</li><li>Set up continuous integration</li><li>Implement versioning and release process</li><li>Design upgrade path for schema evolution</li></ul><p><strong>Deliverables:</strong></p><ul><li>Optimized production build</li><li>Benchmark results and analysis</li><li>Security audit report</li><li>Release artifacts (binaries, headers, documentation)</li></ul><hr><h2 id=dependencies-and-prerequisites>Dependencies and Prerequisites</h2><h3 id=required-tools>Required Tools</h3><ul><li>C11 compliant compiler (GCC 4.9+, Clang 3.4+, MSVC 2015+)</li><li>FlatBuffers compiler (<code>flatc</code>)</li><li>CMake 3.15+ or Meson build system</li><li>Python 3.8+ (for tooling and bindings)</li></ul><h3 id=external-libraries>External Libraries</h3><ul><li>FlatBuffers C library</li><li>Testing framework (e.g., Check, Unity, or cmocka)</li></ul><hr><h2 id=risk-assessment>Risk Assessment</h2><h3 id=technical-risks>Technical Risks</h3><ol><li><p><strong>FlatBuffer performance overhead</strong> - Accessor indirection may slow hot paths</p><ul><li>Mitigation: Benchmark early, optimize critical sections with SIMD, cache hot paths</li></ul></li><li><p><strong>Arena memory overhead</strong> - Long-running computations may accumulate large arenas</p><ul><li>Mitigation: Implement arena compaction, allow arena reuse for similar-sized allocations</li></ul></li><li><p><strong>Determinism on edge cases</strong> - Floating-point operations may vary across platforms</p><ul><li>Mitigation: Use strict FP modes, document platform requirements</li></ul></li><li><p><strong>Schema evolution complexity</strong> - Breaking changes may complicate upgrades</p><ul><li>Mitigation: Version all schemas, maintain compatibility layer</li></ul></li></ol><h3 id=project-risks>Project Risks</h3><ol><li><p><strong>Scope creep</strong> - Feature additions may delay core implementation</p><ul><li>Mitigation: Strict adherence to phased plan, defer non-essential features</li></ul></li><li><p><strong>Documentation debt</strong> - Complex design may be hard to document</p><ul><li>Mitigation: Document schemas and APIs during development, not after</li></ul></li></ol><hr><h2 id=success-criteria>Success Criteria</h2><ol><li>VM can execute procedural scripts with Lua-like semantics</li><li>Dataflow operations match DuckDB&rsquo;s expressiveness for core operators</li><li>Host languages can access VM state without copying memory</li><li>All FlatBuffer regions remain valid and accessible to host</li><li>Execution is deterministic across supported platforms</li><li>Memory safety guaranteed (no UB, no leaks in normal operation)</li><li>Performance within 2x of native C for procedural code</li><li>Performance within 3x of DuckDB for dataflow operations</li></ol><hr><h2 id=timeline-estimation-rough-order>Timeline Estimation (Rough Order)</h2><ul><li><strong>Phase 1:</strong> 2-3 weeks (schema design is iterative)</li><li><strong>Phase 2:</strong> 4-6 weeks (interpreter core is complex)</li><li><strong>Phase 3:</strong> 4-6 weeks (dataflow engine requires careful design)</li><li><strong>Phase 4:</strong> 2-3 weeks (integration layer)</li><li><strong>Phase 5:</strong> 3-4 weeks (host bindings for multiple languages)</li><li><strong>Phase 6:</strong> 4-5 weeks (advanced operators are intricate)</li><li><strong>Phase 7:</strong> 3-4 weeks (safety testing is thorough)</li><li><strong>Phase 8:</strong> 2-3 weeks (tooling development)</li><li><strong>Phase 9:</strong> 2-3 weeks (standard library)</li><li><strong>Phase 10:</strong> 3-4 weeks (optimization and hardening)</li></ul><p><strong>Total estimated effort:</strong> 29-41 weeks (single developer, full-time)</p><p>For a team of 2-3 developers, overlapping phases could reduce calendar time to 6-9 months.</p><hr><h2 id=next-steps>Next Steps</h2><ol><li>Review and validate this plan with stakeholders</li><li>Set up project repository and build infrastructure</li><li>Begin Phase 1: Design and iterate on FlatBuffer schemas</li><li>Create minimal working prototype (simple procedural interpreter)</li><li>Iterate on design based on early implementation learnings</li></ol><div><div>Tags:</div><ul><li><a href=/tags/theta-lang/>Theta-Lang</a></li><li><a href=/tags/vm/>Vm</a></li><li><a href=/tags/design/>Design</a></li><li><a href=/tags/flatbuffers/>Flatbuffers</a></li><li><a href=/tags/dataflow/>Dataflow</a></li></ul></div></main><footer><p>Copyright 2025. All rights reserved.</p></footer></body></html>