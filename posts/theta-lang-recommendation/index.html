<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Theta-lang: Feedback Recommendations | Theta Nil's Site</title><link rel=stylesheet href=/css/main.min.c7a5c1c6627bdd92510df0d2272d0f86694f49366048d0ee3065e20d315759b3.css integrity="sha256-x6XBxmJ73ZJRDfDSJy0PhmlPSTZgSNDuMGXiDTFXWbM=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>function getMermaidTheme(){return window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"default"}function initializeMermaid(){mermaid.initialize({startOnLoad:!1,theme:getMermaidTheme(),securityLevel:"loose",fontFamily:"inherit",themeVariables:{primaryColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#66b3ff":"#00e",primaryTextColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#e8e8e8":"#222",primaryBorderColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#222",lineColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#222",sectionBkgColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#2a2a2a":"#f9f9f9",altSectionBkgColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#1a1a1a":"#fff",gridColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#444":"#e0e0e0",tertiaryColor:window.matchMedia("(prefers-color-scheme: dark)").matches?"#3a3a3a":"#f0f0f0"}})}function processMermaidBlocks(){const e=document.querySelectorAll("code.language-mermaid");e.forEach((e,t)=>{const n=document.createElement("div");n.className="mermaid",n.id="mermaid-"+t,n.textContent=e.textContent;const s=e.parentElement;s.parentElement.replaceChild(n,s)}),e.length>0&&mermaid.init()}if(document.addEventListener("DOMContentLoaded",function(){initializeMermaid(),processMermaidBlocks()}),window.matchMedia){const e=window.matchMedia("(prefers-color-scheme: dark)");e.addEventListener("change",function(){initializeMermaid();const t=document.querySelectorAll(".mermaid");t.forEach((e,t)=>{e.id="mermaid-rerender-"+t,e.removeAttribute("data-processed")}),t.length>0&&mermaid.init()})}</script></head><body><header><h1>Theta Nil's Site</h1><nav><ul><li><a href=/>Home</a></li><li><a aria-current=true class=ancestor href=/posts/>Posts</a></li><li><a href=/tags/>Tags</a></li></ul></nav></header><main><h1>Theta-lang: Feedback Recommendations</h1><time datetime=2025-11-25T00:00:00+00:00>November 25, 2025</time><p>This document summarizes recommendations for several foundational design questions, with pros and cons for each option. These are based on the design and implementation plan for the Theta VM.</p><hr><h2 id=1-schema-organization-one-big-fbs-file-vs-multiple-files>1. Schema Organization: One Big .fbs File vs. Multiple Files</h2><p><strong>Recommendation:</strong> Use multiple .fbs files, organized by subsystem (types, memory, values, instructions, program, execution, operators, dataflow, tables, integration, stdlib).</p><p><strong>Pros:</strong></p><ul><li>Easier to maintain and evolve schemas independently</li><li>Clear separation of concerns; reduces merge conflicts</li><li>Enables targeted regeneration of bindings</li><li>Facilitates schema versioning and compatibility</li></ul><p><strong>Cons:</strong></p><ul><li>Slightly more complex build process (need to include multiple files)</li><li>Cross-file references require careful management</li></ul><hr><h2 id=2-string-handling-interning-vs-direct-storage-utf-8-enforcement>2. String Handling: Interning vs. Direct Storage; UTF-8 Enforcement</h2><p><strong>Recommendation:</strong> Store strings as UTF-8 in FlatBuffers, enforce UTF-8 validity at schema boundaries. Consider optional string interning for frequently repeated values (e.g., column names, identifiers).</p><p><strong>Pros:</strong></p><ul><li>UTF-8 is FlatBuffers&rsquo; default and widely supported</li><li>Direct storage is simple and fast for most cases</li><li>Interning can reduce memory for repeated strings</li></ul><p><strong>Cons:</strong></p><ul><li>Interning adds complexity (need a global pool, lifetime management)</li><li>Enforcing UTF-8 may require validation utilities</li></ul><hr><h2 id=3-buffer-replacement-rebuild-executionstate-every-instruction-vs-batched-updates>3. Buffer Replacement: Rebuild ExecutionState Every Instruction vs. Batched Updates</h2><p><strong>Recommendation:</strong> Use batched updates—rebuild ExecutionState only at control boundaries (function call/return, materialize, etc.), not every instruction.</p><p><strong>Pros:</strong></p><ul><li>Reduces FlatBuffer builder overhead</li><li>Improves performance for tight loops</li><li>Allows host inspection at meaningful points</li></ul><p><strong>Cons:</strong></p><ul><li>VM state may be transiently out of sync with host view</li><li>Requires careful definition of update boundaries</li></ul><hr><h2 id=4-calling-convention-argument-registers-and-stack-fallback>4. Calling Convention: Argument Registers and Stack Fallback</h2><p><strong>Recommendation:</strong> Use a fixed set of argument registers (e.g., r2–r15 for up to 14 args), with stack fallback for additional arguments.</p><p><strong>Pros:</strong></p><ul><li>Fast access for common cases (few arguments)</li><li>Stack fallback supports arbitrarily large signatures</li><li>Matches C-like conventions</li></ul><p><strong>Cons:</strong></p><ul><li>Stack management adds complexity</li><li>Need to define register/stack mapping clearly</li></ul><hr><h2 id=5-branch-encoding-absolute-offsets-vs-relative-jumps>5. Branch Encoding: Absolute Offsets vs. Relative Jumps</h2><p><strong>Recommendation:</strong> Use absolute offsets for branch targets in instruction encoding.</p><p><strong>Pros:</strong></p><ul><li>Easier to decode and validate</li><li>More robust to code motion and optimization</li><li>Simplifies disassembly and debugging</li></ul><p><strong>Cons:</strong></p><ul><li>Slightly larger encoding for each branch</li><li>Code relocation requires offset adjustment</li></ul><hr><h2 id=6-instruction-size-fixed-32-bit-vs-variable-length>6. Instruction Size: Fixed 32-bit vs. Variable-Length</h2><p><strong>Recommendation:</strong> Use fixed-size (e.g., 32-bit) instructions for the core ISA.</p><p><strong>Pros:</strong></p><ul><li>Fast decoding and predictable memory access</li><li>SIMD-friendly and cache-efficient</li><li>Simplifies instruction fetch and dispatch</li></ul><p><strong>Cons:</strong></p><ul><li>May waste space for simple instructions</li><li>Complex instructions may need multiple slots or extension</li></ul><hr><h2 id=7-processing-model-pure-streaming-vs-batching>7. Processing Model: Pure Streaming vs. Batching</h2><p><strong>Recommendation:</strong> Support both streaming (pull-based iterators) and batching (materialize entire table), with streaming as the default for dataflow.</p><p><strong>Pros:</strong></p><ul><li>Streaming enables low-latency, memory-efficient execution</li><li>Batching is useful for host extraction and bulk operations</li><li>Flexible for different workloads</li></ul><p><strong>Cons:</strong></p><ul><li>Dual model adds implementation complexity</li><li>Need to define clear API for switching modes</li></ul><hr><h2 id=8-thread-safety-single-threaded-vs-concurrent-access>8. Thread Safety: Single-Threaded vs. Concurrent Access</h2><p><strong>Recommendation:</strong> Start with single-threaded VM core; design FlatBuffer regions and arenas to allow concurrent host access (read-only) and future multi-threaded extensions.</p><p><strong>Pros:</strong></p><ul><li>Simpler initial implementation</li><li>FlatBuffers&rsquo; immutability enables safe concurrent reads</li><li>Can evolve to multi-threaded execution later</li></ul><p><strong>Cons:</strong></p><ul><li>No parallel execution in initial version</li><li>Must document thread safety guarantees for host integration</li></ul><hr><h2 id=next-steps>Next Steps</h2><ul><li>Begin schema design using multiple .fbs files as outlined in the plan</li><li>Implement UTF-8 validation utilities and consider string interning for identifiers</li><li>Define update boundaries for ExecutionState</li><li>Specify calling convention and register/stack mapping</li><li>Document branch encoding and instruction format</li><li>Design streaming/batching API for dataflow</li><li>Clarify thread safety in host API documentation</li></ul><div><div>Tags:</div><ul><li><a href=/tags/theta-lang/>Theta-Lang</a></li><li><a href=/tags/vm/>Vm</a></li><li><a href=/tags/design/>Design</a></li><li><a href=/tags/flatbuffers/>Flatbuffers</a></li><li><a href=/tags/dataflow/>Dataflow</a></li></ul></div></main><footer><p>Copyright 2025. All rights reserved.</p></footer></body></html>